<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge Curator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; }
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback, useRef, useEffect, useMemo } = React;

// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SEATS = ["N", "E", "S", "W"];
const SUIT_ORDER = ["S", "H", "D", "C"];
const SUIT_SYMBOLS = { S: "â™ ", H: "â™¥", D: "â™¦", C: "â™£" };
const SUIT_COLORS = { S: "#1a3a5c", H: "#c0392b", D: "#e67e22", C: "#2d6a4f" };
const RANK_ORDER = ["A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2"];
const SEAT_NAMES = { N: "North", E: "East", S: "South", W: "West" };
const VULNERABILITIES = ["None", "NS", "EW", "Both"];

const SKILL_PATHS = [
  "basic_bidding/major_suit_openings", "basic_bidding/minor_suit_openings",
  "basic_bidding/notrump_openings",
  "bidding_conventions/blackwood", "bidding_conventions/fourth_suit_forcing",
  "bidding_conventions/help_suit_game_try", "bidding_conventions/jacoby_2nt_splinters",
  "bidding_conventions/jacoby_transfers", "bidding_conventions/new_minor_forcing",
  "bidding_conventions/ogust", "bidding_conventions/preemptive_bids",
  "bidding_conventions/reverse_bids", "bidding_conventions/reverse_drury",
  "bidding_conventions/roman_keycard", "bidding_conventions/stayman",
  "bidding_conventions/strong_2c", "bidding_conventions/two_over_one",
  "bidding_conventions/weak_2s",
  "competitive_bidding/dont", "competitive_bidding/lebensohl",
  "competitive_bidding/michaels_unusual", "competitive_bidding/negative_doubles",
  "competitive_bidding/overcalls", "competitive_bidding/support_cuebids",
  "competitive_bidding/takeout_doubles",
  "declarer_play/elimination_plays", "declarer_play/entry_management",
  "declarer_play/finessing", "declarer_play/holdup_plays",
  "declarer_play/squeeze_plays", "declarer_play/suit_establishment",
  "declarer_play/trump_management",
  "defense/defensive_signals", "defense/opening_leads",
  "defense/second_hand_play", "defense/third_hand_play",
  "partnership_bidding/advanced_forcing", "partnership_bidding/basic_bidding",
  "partnership_bidding/basic_major", "partnership_bidding/basic_notrump",
  "partnership_bidding/blackwood", "partnership_bidding/jacoby_2nt",
  "partnership_bidding/negative_doubles", "partnership_bidding/overcalls",
  "partnership_bidding/roman_key_card", "partnership_bidding/stayman_transfers",
  "partnership_bidding/two_club", "partnership_bidding/weak_twos",
  "practice_deals/100_miscellaneous", "practice_deals/100_notrump",
];

const CATEGORIES = [
  "Basic Bidding", "Bidding Conventions", "Competitive Bidding",
  "Declarer Play", "Defense", "Partnership Bidding",
  "Slam Bidding", "Card Play Techniques", "Practice Deals",
];

const DIFFICULTIES = ["beginner", "intermediate", "advanced"];

// â”€â”€ Lesson Templates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TEMPLATES = {
  bidding: {
    name: "Bidding", icon: "ðŸ—£", desc: "Student makes bidding decisions",
    defaultStudent: "S",
    scenes: [
      { visibility: "S", text: "", showcards: [], hint: "Set up the bidding problem. Add a [BID] prompt." },
      { visibility: "NESW", text: "", showcards: [], hint: "Explain the correct bid and reveal all hands." },
    ],
  },
  declaring: {
    name: "Declaring", icon: "ðŸƒ", desc: "Student plays as declarer",
    defaultStudent: "S",
    scenes: [
      { visibility: "NS", text: "", showcards: [], hint: "Describe the opening lead and initial plan." },
      { visibility: "NS", text: "", showcards: [], hint: "Walk through card play with [choose-card] prompts." },
      { visibility: "NESW", text: "", showcards: [], hint: "Reveal all hands and explain the full line." },
    ],
  },
  bidding_declaring: {
    name: "Bidding + Declaring", icon: "ðŸŽ¯", desc: "Bidding then card play",
    defaultStudent: "S",
    scenes: [
      { visibility: "S", text: "", showcards: [], hint: "First bidding decision." },
      { visibility: "S", text: "", showcards: [], hint: "Continue the auction with [BID] prompts." },
      { visibility: "NS", text: "", showcards: [], hint: "Transition to card play." },
      { visibility: "NESW", text: "", showcards: [], hint: "Full reveal and explanation." },
    ],
  },
  opening_lead: {
    name: "Opening Lead", icon: "âž¡ï¸", desc: "Student selects the opening lead",
    defaultStudent: "W",
    scenes: [
      { visibility: "W", text: "", showcards: [], hint: "Add a [choose-card] prompt for the lead." },
      { visibility: "NESW", text: "", showcards: [], hint: "Reveal all hands and explain the lead choice." },
    ],
  },
  second_hand: {
    name: "2nd Hand Play", icon: "âœŒï¸", desc: "Student plays second to the trick",
    defaultStudent: "S",
    scenes: [
      { visibility: "NS", text: "", showcards: [], hint: "Show the card led and ask for 2nd hand play." },
      { visibility: "NESW", text: "", showcards: [], hint: "Explain the correct play." },
    ],
  },
  third_hand: {
    name: "3rd Hand Play", icon: "ðŸ¥‰", desc: "Student plays third to the trick",
    defaultStudent: "E",
    scenes: [
      { visibility: "NE", text: "", showcards: [], hint: "Show the lead and dummy, ask for 3rd hand play." },
      { visibility: "NESW", text: "", showcards: [], hint: "Explain the correct play." },
    ],
  },
  blank: {
    name: "Blank", icon: "ðŸ“„", desc: "Start from scratch",
    defaultStudent: "S",
    scenes: [
      { visibility: "NESW", text: "", showcards: [], hint: "Build your own storyboard." },
    ],
  },
};

// â”€â”€ PBN Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parsePBNDeal(dealStr) {
  const hands = { N: [], E: [], S: [], W: [] };
  if (!dealStr) return hands;
  const match = dealStr.match(/([NESW]):(.+)/);
  if (!match) return hands;
  const firstSeat = match[1];
  const handStrs = match[2].split(/\s+/);
  const seatOrder = [...SEATS.slice(SEATS.indexOf(firstSeat)), ...SEATS.slice(0, SEATS.indexOf(firstSeat))];
  handStrs.forEach((h, i) => {
    const seat = seatOrder[i];
    if (!seat || h === "-") return; // skip unknown hands
    const suits = h.split(".");
    SUIT_ORDER.forEach((suit, si) => {
      const ranks = suits[si] || "";
      for (const r of ranks) hands[seat].push(suit + r);
    });
  });
  return hands;
}

function handToDealString(hands, firstSeat = "N") {
  const seatOrder = [...SEATS.slice(SEATS.indexOf(firstSeat)), ...SEATS.slice(0, SEATS.indexOf(firstSeat))];
  const parts = seatOrder.map(seat => {
    return SUIT_ORDER.map(suit => {
      return hands[seat]
        .filter(c => c[0] === suit)
        .map(c => c[1])
        .sort((a, b) => RANK_ORDER.indexOf(a) - RANK_ORDER.indexOf(b))
        .join("");
    }).join(".");
  });
  return firstSeat + ":" + parts.join(" ");
}

// â”€â”€ Deal Rotation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rotate a direction character by `steps` positions clockwise (0-3)
function rotateSeat(seat, steps) {
  return SEATS[(SEATS.indexOf(seat) + steps) % 4];
}

// Rotate direction words in text (Northâ†”South, Eastâ†”West, etc.)
function rotateDirectionWords(text, steps) {
  if (steps === 0) return text;
  const dirs = ["North", "East", "South", "West"];
  // First pass: replace with placeholders to avoid double-replacement
  let result = text;
  dirs.forEach((d, i) => {
    result = result.replace(new RegExp(`\\b${d}\\b`, "gi"), (m) => {
      const allUpper = m === m.toUpperCase();
      const titleCase = m[0] === m[0].toUpperCase();
      if (allUpper) return `__DIR_U${i}__`;
      if (titleCase) return `__DIR_T${i}__`;
      return `__DIR_L${i}__`;
    });
  });
  // Second pass: replace placeholders with rotated directions
  dirs.forEach((_, i) => {
    const newDir = dirs[(i + steps) % 4];
    result = result
      .replace(new RegExp(`__DIR_T${i}__`, "g"), newDir)
      .replace(new RegExp(`__DIR_L${i}__`, "g"), newDir.toLowerCase())
      .replace(new RegExp(`__DIR_U${i}__`, "g"), newDir.toUpperCase());
  });
  return result;
}

// Rotate [show NESW] tags in scene text
function rotateShowTags(text, steps) {
  return text.replace(/\[show\s+([NESW]+)\]/gi, (match, seats) => {
    const rotated = seats.split("").map(s => rotateSeat(s.toUpperCase(), steps)).sort((a, b) => SEATS.indexOf(a) - SEATS.indexOf(b)).join("");
    return `[show ${rotated}]`;
  });
}

// Rotate a board object by `steps` positions clockwise (1=90Â°, 2=180Â°, 3=270Â°)
// Returns a new board object; does not mutate the original.
function rotateBoard(board, steps) {
  steps = ((steps % 4) + 4) % 4; // normalize to 0-3
  if (steps === 0) return board;

  // Rotate hands: each seat gets the hand from `steps` positions earlier
  const newHands = {};
  for (const seat of SEATS) {
    const sourceSeat = rotateSeat(seat, (4 - steps) % 4);
    newHands[seat] = [...(board.hands[sourceSeat] || [])];
  }

  // Rotate dealer and student
  const newDealer = rotateSeat(board.dealer || "N", steps);
  const newStudent = board.student ? rotateSeat(board.student, steps) : board.student;

  // Vulnerability: for odd rotations, swap NSâ†”EW
  let newVul = board.vulnerable;
  if (steps % 2 === 1) {
    if (newVul === "NS") newVul = "EW";
    else if (newVul === "EW") newVul = "NS";
  }

  // Rotate scenes (show tags + direction words in commentary)
  let newScenes = board.scenes;
  if (board.scenes) {
    newScenes = board.scenes.map(scene => ({
      ...scene,
      visibility: scene.visibility
        ? scene.visibility.split("").map(s => rotateSeat(s, steps)).sort((a, b) => SEATS.indexOf(a) - SEATS.indexOf(b)).join("")
        : scene.visibility,
      text: rotateDirectionWords(rotateShowTags(scene.text, steps), steps),
    }));
  }

  return {
    ...board,
    hands: newHands,
    dealer: newDealer,
    student: newStudent,
    vulnerable: newVul,
    scenes: newScenes,
  };
}

function parsePBNFile(text) {
  const boards = [];
  // Strategy: split on [Event lines, which mark the start of each board record.
  // If no [Event tags, fall back to splitting on [Board or [Dealer.
  const hasEvent = /^\[Event\s+"/m.test(text);
  const splitTag = hasEvent ? "Event" : (/^\[Board\s+"/m.test(text) ? "Board" : "Dealer");
  const splitRegex = new RegExp(`^\\[${splitTag}\\s+"`, "m");

  const lines = text.split("\n");
  let currentLines = [];
  let inBoard = false;
  let inCommentary = false;

  for (const line of lines) {
    const trimmed = line.trim();
    // Track whether we're inside a { } commentary block
    if (!inCommentary && trimmed.includes("{")) inCommentary = true;
    if (inCommentary && trimmed.includes("}")) inCommentary = false;

    // Only split on the chosen tag, and not while inside a commentary block
    if (!inCommentary && splitRegex.test(trimmed)) {
      if (currentLines.length > 0 && inBoard) {
        boards.push(parseSingleBoard(currentLines.join("\n")));
      }
      currentLines = [line];
      inBoard = true;
    } else {
      currentLines.push(line);
    }
  }
  if (currentLines.length > 0 && inBoard) boards.push(parseSingleBoard(currentLines.join("\n")));
  if (boards.length === 0 && text.trim()) boards.push(parseSingleBoard(text));
  return boards;
}

function parseSingleBoard(text) {
  const tags = {};
  const tagRegex = /\[(\w+)\s+"([^"]*)"\]/g;
  let m;
  while ((m = tagRegex.exec(text)) !== null) tags[m[1]] = m[2];

  // Extract ALL commentary blocks { ... }
  const commentBlocks = [];
  const commentBlockRe = /\{([^}]*)\}/g;
  let cm;
  while ((cm = commentBlockRe.exec(text)) !== null) {
    commentBlocks.push(cm[1].trim());
  }

  // Classify commentary: metadata vs lesson content
  // Metadata blocks are short, single-line, and start with keywords like Shape, HCP, Losers
  const metadataPatterns = /^(Shape|HCP|Losers|Points|Controls|DOP)\b/i;
  const metadataBlocks = [];
  const lessonBlocks = [];
  for (const block of commentBlocks) {
    if (metadataPatterns.test(block) && !block.includes("\n") && block.length < 100) {
      metadataBlocks.push(block);
    } else {
      lessonBlocks.push(block);
    }
  }

  // Lesson commentary is the combined lesson blocks (usually 0 or 1)
  const commentary = lessonBlocks.join("\n\n");
  // Preserve metadata for display/reference
  const metadata = metadataBlocks;

  // Parse [Note "N:text"] tags for alert descriptions
  const notes = {};
  const noteRe = /\[Note\s+"(\d+):([^"]*)"\]/g;
  let nm;
  while ((nm = noteRe.exec(text)) !== null) notes[nm[1]] = nm[2];

  let auctionBids = [];
  const auctionTagMatch = text.match(/\[Auction\s+"([NESW])"\]\s*\n([\s\S]*?)(?=\n\[|\n\{|$)/);
  if (auctionTagMatch) {
    const tokens = auctionTagMatch[2].trim().split(/\s+/).filter(Boolean);
    // Walk tokens, pairing bids with =N= alert annotations
    let i = 0;
    while (i < tokens.length) {
      const tok = tokens[i];
      // Skip $N NAG annotations
      if (/^\$\d+$/.test(tok)) { i++; continue; }
      // Skip bare = or =N= (handled as lookahead below)
      if (/^=\d*=?$/.test(tok)) { i++; continue; }
      // Expand AP (All Pass) into 3 passes
      if (tok === "AP") {
        auctionBids.push({ bid: "Pass" }, { bid: "Pass" }, { bid: "Pass" });
        i++; continue;
      }
      // Normalize bid
      let bid;
      const lo = tok.toLowerCase();
      if (lo === "pass") bid = "Pass";
      else if (lo === "dbl" || lo === "double" || lo === "x") bid = "Dbl";
      else if (lo === "rdbl" || lo === "redouble" || lo === "xx") bid = "Rdbl";
      else bid = tok;
      // Check if next token is an =N= alert annotation
      const entry = { bid };
      if (i + 1 < tokens.length && /^=(\d+)=$/.test(tokens[i + 1])) {
        const noteNum = tokens[i + 1].match(/^=(\d+)=$/)[1];
        if (notes[noteNum]) entry.alert = notes[noteNum];
        else entry.alert = "";
        i++; // skip the =N= token
      }
      auctionBids.push(entry);
      i++;
    }
  }
  return {
    event: tags.Event || "", board: tags.Board || "",
    dealer: tags.Dealer || "N", vulnerable: tags.Vulnerable || "None",
    deal: tags.Deal || "", hands: parsePBNDeal(tags.Deal || ""),
    auction: auctionBids, student: tags.Student || "",
    category: tags.Category || "", difficulty: tags.Difficulty || "",
    skillPath: tags.SkillPath || "", commentary, metadata,
    scenes: null, templateKey: null, included: true, rawText: text,
  };
}

// â”€â”€ Commentary Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseCommentary(text) {
  if (!text.trim()) return null;
  const scenes = [];
  let current = { text: "", visibility: "NESW", showcards: [], hint: "" };
  const lines = text.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    // [show X] â€” keep in text AND use to set visibility
    const showMatch = trimmed.match(/^\[show\s+([NESW]+)\]$/i);
    if (showMatch) {
      if (current.text.trim()) {
        scenes.push(current);
        current = { text: line, visibility: showMatch[1].toUpperCase(), showcards: [], hint: "" };
      } else {
        current.visibility = showMatch[1].toUpperCase();
        current.text += (current.text ? "\n" : "") + line;
      }
      continue;
    }
    // [showcards X] â€” keep in text
    const showcardsMatch = trimmed.match(/^\[showcards\s+(.+)\]$/i);
    if (showcardsMatch) {
      current.showcards.push(showcardsMatch[1]);
      current.text += (current.text ? "\n" : "") + line;
      continue;
    }
    // [NEXT] â€” keep in text at end of current scene, then split
    if (/\[NEXT\]/i.test(trimmed)) {
      current.text += (current.text ? "\n" : "") + line;
      scenes.push(current);
      current = { text: "", visibility: current.visibility, showcards: [], hint: "" };
      continue;
    }
    if (line.trim()) current.text += (current.text ? "\n" : "") + line;
  }
  if (current.text.trim() || scenes.length === 0) scenes.push(current);
  return scenes;
}

function scenesToCommentary(scenes) {
  return scenes.map(s => s.text.trim()).join("\n");
}

function exportBoard(board) {
  const lines = [];
  if (board.event) lines.push(`[Event "${board.event}"]`);
  if (board.board) lines.push(`[Board "${board.board}"]`);
  lines.push(`[Dealer "${board.dealer}"]`);
  lines.push(`[Vulnerable "${board.vulnerable}"]`);
  // Regenerate deal string from hands (reflects any card swaps)
  const hasCards = Object.values(board.hands).some(h => h.length > 0);
  if (hasCards) {
    lines.push(`[Deal "${handToDealString(board.hands)}"]`);
  } else if (board.deal) {
    lines.push(`[Deal "${board.deal}"]`);
  }
  if (board.student) lines.push(`[Student "${board.student}"]`);
  if (board.category) lines.push(`[Category "${board.category}"]`);
  if (board.difficulty) lines.push(`[Difficulty "${board.difficulty}"]`);
  if (board.skillPath) lines.push(`[SkillPath "${board.skillPath}"]`);
  if (board.auction.length) {
    lines.push(`[Auction "${board.dealer}"]`);
    // Build auction line with =N= alert annotations
    let alertNum = 0;
    const alertNotes = [];
    const bidTokens = board.auction.map(entry => {
      const tok = entry.bid;
      if (entry.alert != null && entry.alert !== undefined) {
        alertNum++;
        alertNotes.push(`[Note "${alertNum}:${entry.alert}"]`);
        return `${tok} =${alertNum}=`;
      }
      return tok;
    });
    lines.push(bidTokens.join(" "));
    alertNotes.forEach(n => lines.push(n));
  }
  if (board.scenes && board.scenes.length > 0) {
    const commentary = scenesToCommentary(board.scenes);
    if (commentary) lines.push(`{${commentary}}`);
  }
  return lines.join("\n");
}

function exportIncludedBoards(boards) {
  return boards.filter(b => b.included).map(b => exportBoard(b)).join("\n\n");
}

function formatText(text) {
  return text
    .replace(/\\S/g, "\u2660").replace(/\\H/g, "\u2665").replace(/\\D/g, "\u2666").replace(/\\C/g, "\u2663")
    .replace(/\\s/g, "\u2660").replace(/\\h/g, "\u2665").replace(/\\d/g, "\u2666").replace(/\\c/g, "\u2663");
}

// Rich text renderer: colored suits + highlighted tags (for preview)
const SUIT_REPLACE_RE = /\\[SsDdHhCc]/g;
const FORMATTED_TAG_RE = /\[(BID|choose-card|PLAY|showcards|NEXT|ROTATE|show)(\s[^\]]*)?\]/gi;
const FORMATTED_SPLIT_RE = /(\\[SsDdHhCc]|\[(BID|choose-card|PLAY|showcards|NEXT|ROTATE|show)(?:\s[^\]]*)?\])/gi;

function FormattedText({ text, dimmed }) {
  if (!text) return null;
  const tokens = [];
  let lastIndex = 0;
  const combined = new RegExp(FORMATTED_SPLIT_RE.source, "gi");
  let m;
  while ((m = combined.exec(text)) !== null) {
    if (m.index > lastIndex) tokens.push({ type: "text", value: text.slice(lastIndex, m.index) });
    tokens.push({ type: "special", value: m[0] });
    lastIndex = m.index + m[0].length;
  }
  if (lastIndex < text.length) tokens.push({ type: "text", value: text.slice(lastIndex) });

  const grey = "#9ca3af";
  return React.createElement(React.Fragment, null, tokens.map((tok, idx) => {
    if (tok.type === "text") return React.createElement("span", { key: idx }, tok.value);
    // Suit symbol
    const suitMatch = tok.value.match(/^\\([SsDdHhCc])$/);
    if (suitMatch) {
      const ch = suitMatch[1].toUpperCase();
      const sym = { S: "\u2660", H: "\u2665", D: "\u2666", C: "\u2663" }[ch];
      const color = dimmed ? grey : (ch === "H" || ch === "D") ? "#c0392b" : "#1a3a5c";
      return React.createElement("span", { key: idx, style: { color, fontWeight: 600 } }, sym);
    }
    // Control tag
    const tagMatch = tok.value.match(/^\[(\w[\w-]*)/i);
    if (tagMatch) {
      const tag = tagMatch[1];
      const key = Object.keys(TAG_HIGHLIGHT_STYLES).find(k => k.toLowerCase() === tag.toLowerCase());
      const s = key ? TAG_HIGHLIGHT_STYLES[key] : null;
      if (s) {
        return React.createElement("span", { key: idx, style: {
          color: dimmed ? grey : s.color, background: dimmed ? "#f1f5f9" : s.background,
          borderRadius: 3, padding: "0 3px", fontWeight: 600,
          fontFamily: "'JetBrains Mono', monospace", fontSize: "0.9em",
        }}, tok.value);
      }
    }
    return React.createElement("span", { key: idx }, tok.value);
  }));
}

// â”€â”€ Card Component (draggable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DraggableCard({ card, seat, dimmed, highlighted, onDragStart, onDragOver, onDrop }) {
  const suit = card[0];
  const rank = card.substring(1);
  const displayRank = rank === "T" ? "10" : rank;
  const [isOver, setIsOver] = useState(false);

  return (
    <span
      draggable
      onDragStart={(e) => {
        const el = document.createElement("span");
        el.textContent = SUIT_SYMBOLS[suit] + displayRank;
        el.style.cssText = `position:absolute;top:-100px;font-size:18px;font-weight:700;color:${SUIT_COLORS[suit]};font-family:'JetBrains Mono',monospace;background:#fff;padding:4px 8px;border-radius:4px;border:2px solid ${SUIT_COLORS[suit]}`;
        document.body.appendChild(el);
        e.dataTransfer.setDragImage(el, 20, 16);
        setTimeout(() => document.body.removeChild(el), 0);
        e.dataTransfer.setData("text/plain", JSON.stringify({ card, seat }));
        if (onDragStart) onDragStart(card, seat);
      }}
      onDragOver={(e) => { e.preventDefault(); setIsOver(true); }}
      onDragLeave={() => setIsOver(false)}
      onDrop={(e) => {
        e.preventDefault();
        setIsOver(false);
        try {
          const data = JSON.parse(e.dataTransfer.getData("text/plain"));
          if (onDrop) onDrop(data.card, data.seat, card, seat);
        } catch {}
      }}
      style={{
        display: "inline-flex", alignItems: "center",
        padding: "0px 2px", margin: "0px",
        borderRadius: 3,
        color: SUIT_COLORS[suit],
        fontWeight: 700,
        fontSize: 12,
        fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
        opacity: dimmed ? 0.35 : 1,
        cursor: "grab",
        background: highlighted ? "rgba(250, 204, 21, 0.35)" : isOver ? "#fef3c7" : "transparent",
        border: isOver ? "1.5px solid #f59e0b" : "1.5px solid transparent",
        boxShadow: highlighted ? "0 0 8px rgba(250, 204, 21, 0.6)" : "none",
        transition: "background 0.3s ease, box-shadow 0.3s ease",
        userSelect: "none",
        lineHeight: 1.2,
      }}
    >
      {displayRank}
    </span>
  );
}

// â”€â”€ Hand Display (always shown, dimmed if hidden) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function HandDisplay({ hand, seat, visible, onSwapCards, highlightedCards }) {
  const bySuit = useMemo(() => {
    const m = {};
    SUIT_ORDER.forEach(s => { m[s] = []; });
    hand.forEach(c => m[c[0]].push(c));
    Object.keys(m).forEach(s => {
      m[s].sort((a, b) => RANK_ORDER.indexOf(a[1]) - RANK_ORDER.indexOf(b[1]));
    });
    return m;
  }, [hand]);

  const dimmed = !visible;

  return (
    <div style={{
      padding: "5px 6px", borderRadius: 6, minWidth: 100,
      background: dimmed ? "#f8fafc" : "#fff",
      border: dimmed ? "1.5px dashed #cbd5e1" : "1.5px solid #3b82f6",
      transition: "all 0.15s ease",
    }}>
      <div style={{
        fontSize: 10, fontWeight: 700, textTransform: "uppercase",
        letterSpacing: "0.05em",
        color: dimmed ? "#94a3b8" : "#3b82f6",
        marginBottom: 2,
        fontFamily: "'DM Sans', sans-serif",
        display: "flex", alignItems: "center", gap: 4,
      }}>
        {SEAT_NAMES[seat]}
        {dimmed && <span style={{ fontSize: 8, fontWeight: 400, fontStyle: "italic", textTransform: "none" }}>hidden</span>}
      </div>
      {SUIT_ORDER.map(suit => (
        <div key={suit} style={{ display: "flex", alignItems: "center", gap: 0, minHeight: 18, lineHeight: 1.1 }}>
          <span style={{
            color: SUIT_COLORS[suit], fontWeight: 700, fontSize: 12, width: 14, textAlign: "center",
            opacity: dimmed ? 0.35 : 1, flexShrink: 0,
          }}>
            {SUIT_SYMBOLS[suit]}
          </span>
          <div style={{ display: "flex", flexWrap: "wrap", gap: 0 }}>
            {bySuit[suit].length > 0 ? bySuit[suit].map(c => (
              <DraggableCard
                key={c}
                card={c}
                seat={seat}
                dimmed={dimmed}
                highlighted={!!(highlightedCards && highlightedCards[c + ":" + seat])}
                onDrop={onSwapCards}
              />
            )) : (
              <span style={{ color: "#cbd5e1", fontSize: 12, fontStyle: "italic", opacity: dimmed ? 0.35 : 1, padding: "0 4px" }}>â€”</span>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}

// â”€â”€ Board Diagram â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function BoardDiagram({ hands, visibility, compact, onSwapCards, highlightedCards, hideInvisible }) {
  const vis = (seat) => visibility.includes(seat);
  const show = (seat) => !hideInvisible || vis(seat);
  return (
    <div style={{
      display: "grid", gridTemplateColumns: "1fr auto 1fr",
      gridTemplateRows: "auto auto auto",
      gap: compact ? 4 : 6, alignItems: "center", justifyItems: "center",
      padding: compact ? 6 : 8,
    }}>
      <div style={{ gridColumn: "2", gridRow: "1" }}>
        {show("N") && <HandDisplay hand={hands.N} seat="N" visible={vis("N")} onSwapCards={onSwapCards} highlightedCards={highlightedCards} />}
      </div>
      <div style={{ gridColumn: "1", gridRow: "2", justifySelf: "end" }}>
        {show("W") && <HandDisplay hand={hands.W} seat="W" visible={vis("W")} onSwapCards={onSwapCards} highlightedCards={highlightedCards} />}
      </div>
      <div style={{
        gridColumn: "2", gridRow: "2", width: compact ? 40 : 48, height: compact ? 40 : 48,
        borderRadius: "50%",
        background: "linear-gradient(135deg, #1e293b, #334155)",
        display: "flex", alignItems: "center", justifyContent: "center",
        color: "#94a3b8", fontSize: compact ? 8 : 9, fontWeight: 700,
        fontFamily: "'DM Sans', sans-serif",
      }}>
        <div style={{ textAlign: "center", lineHeight: 1.3 }}>
          <div>N</div><div>W Â· E</div><div>S</div>
        </div>
      </div>
      <div style={{ gridColumn: "3", gridRow: "2", justifySelf: "start" }}>
        {show("E") && <HandDisplay hand={hands.E} seat="E" visible={vis("E")} onSwapCards={onSwapCards} highlightedCards={highlightedCards} />}
      </div>
      <div style={{ gridColumn: "2", gridRow: "3" }}>
        {show("S") && <HandDisplay hand={hands.S} seat="S" visible={vis("S")} onSwapCards={onSwapCards} highlightedCards={highlightedCards} />}
      </div>
    </div>
  );
}

// â”€â”€ Suit symbol rendering for text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSuitText(text) {
  if (!text) return text;
  const parts = text.split(/(\\[SHDCshdc]s?|â™ |â™¥|â™¦|â™£)/g);
  return parts.map((part, i) => {
    const lo = part.toLowerCase();
    if (lo === "\\s" || lo === "\\ss" || part === "â™ ") return <span key={i} style={{ color: SUIT_COLORS.S }}>â™ </span>;
    if (lo === "\\h" || lo === "\\hs" || part === "â™¥") return <span key={i} style={{ color: SUIT_COLORS.H }}>â™¥</span>;
    if (lo === "\\d" || lo === "\\ds" || part === "â™¦") return <span key={i} style={{ color: SUIT_COLORS.D }}>â™¦</span>;
    if (lo === "\\c" || lo === "\\cs" || part === "â™£") return <span key={i} style={{ color: SUIT_COLORS.C }}>â™£</span>;
    return part;
  });
}

// â”€â”€ Auction Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// auction entries are { bid, alert? } objects (or plain strings for legacy/preview "?" bids)
function AuctionDisplay({ auction, dealer, compact, onBidClick }) {
  if (!auction.length) return (
    <div style={{ color: "#94a3b8", fontSize: 12, fontStyle: "italic", textAlign: "center", padding: 6 }}>
      No auction
    </div>
  );
  // Build alert number map (only alerted bids get sequential numbers)
  let alertNum = 0;
  const alertMap = auction.map(entry => {
    const e = typeof entry === "string" ? { bid: entry } : entry;
    if (e.alert != null) { alertNum++; return { ...e, alertNum }; }
    return e;
  });

  const dealerIdx = SEATS.indexOf(dealer);
  const cells = [];
  for (let i = 0; i < dealerIdx; i++) cells.push(<td key={`e${i}`}></td>);
  alertMap.forEach((entry, i) => {
    const bid = entry.bid;
    const isQuestion = bid === "?";
    let display = isQuestion ? "?" : bid.replace(/(\d)S/g, "$1â™ ").replace(/(\d)H/g, "$1â™¥")
      .replace(/(\d)D/g, "$1â™¦").replace(/(\d)C/g, "$1â™£");
    let color = "#334155";
    let background = "transparent";
    if (isQuestion) {
      color = "#3b82f6";
      background = "#eff6ff";
    } else if (/\dH/.test(bid)) color = SUIT_COLORS.H;
    else if (/\dD/.test(bid)) color = SUIT_COLORS.D;
    else if (bid.includes("C") && !bid.startsWith("Pa")) color = SUIT_COLORS.C;
    else if (/\dS/.test(bid)) color = SUIT_COLORS.S;
    const clickable = onBidClick && !isQuestion;
    cells.push(
      <td key={i} style={{
        padding: compact ? "1px 4px" : "2px 6px", fontWeight: 600, color,
        fontSize: isQuestion ? (compact ? 14 : 16) : (compact ? 12 : 13),
        fontFamily: "'JetBrains Mono', monospace", textAlign: "center",
        background, cursor: clickable ? "pointer" : "default",
      }} onClick={clickable ? () => onBidClick(i) : undefined}>
        {display}
        {entry.alertNum && (
          <sup style={{ fontSize: 8, fontWeight: 700, color: "#dc2626" }}>{entry.alertNum}</sup>
        )}
      </td>
    );
  });
  const rows = [];
  for (let i = 0; i < cells.length; i += 4) {
    rows.push(<tr key={i}>{cells.slice(i, i + 4)}{Array.from({ length: Math.max(0, 4 - (cells.length - i)) }, (_, j) => <td key={`p${j}`}></td>)}</tr>);
  }
  // Collect alert footnotes
  const footnotes = alertMap.filter(e => e.alertNum);
  return (
    <div>
      <table style={{ borderCollapse: "collapse", width: "100%" }}>
        <thead><tr>{SEATS.map(s => (
          <th key={s} style={{
            padding: "2px 6px", fontSize: 10, fontWeight: 700, color: "#64748b",
            textTransform: "uppercase", letterSpacing: "0.05em",
            borderBottom: "1px solid #e2e8f0", fontFamily: "'DM Sans', sans-serif",
          }}>{s}</th>
        ))}</tr></thead>
        <tbody>{rows}</tbody>
      </table>
      {footnotes.length > 0 && (
        <div style={{ padding: "4px 6px", fontSize: 11, color: "#64748b", borderTop: "1px solid #f1f5f9" }}>
          {footnotes.map(f => (
            <div key={f.alertNum} style={{ lineHeight: 1.4 }}>
              <span style={{ color: "#dc2626", fontWeight: 700 }}>{f.alertNum}</span>: {renderSuitText(f.alert)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

// â”€â”€ Alert Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function AlertDialog({ bid, alert, onSave, onClear, onClose }) {
  const [text, setText] = useState(alert || "");
  const inputRef = useRef(null);
  useEffect(() => { inputRef.current?.focus(); }, []);
  const bidDisplay = bid.replace(/(\d)S/g, "$1â™ ").replace(/(\d)H/g, "$1â™¥")
    .replace(/(\d)D/g, "$1â™¦").replace(/(\d)C/g, "$1â™£");
  return (
    <div style={{
      position: "fixed", inset: 0, background: "rgba(15,23,42,0.4)",
      display: "flex", alignItems: "center", justifyContent: "center", zIndex: 110,
    }} onClick={(e) => { if (e.target === e.currentTarget) onClose(); }}>
      <div style={{
        background: "#fff", borderRadius: 10, padding: 16, width: 320,
        boxShadow: "0 12px 40px rgba(0,0,0,0.15)", fontFamily: "'DM Sans', sans-serif",
      }}>
        <div style={{ fontSize: 14, fontWeight: 700, color: "#0f172a", marginBottom: 10 }}>
          Alert for <span style={{ fontFamily: "'JetBrains Mono', monospace" }}>{bidDisplay}</span>
        </div>
        <input ref={inputRef} value={text} onChange={e => setText(e.target.value)}
          placeholder="e.g. 8 or more HCP"
          onKeyDown={e => { if (e.key === "Enter") { onSave(text); } if (e.key === "Escape") onClose(); }}
          style={{
            width: "100%", padding: "8px 10px", fontSize: 13, borderRadius: 6,
            border: "1.5px solid #e2e8f0", outline: "none", fontFamily: "'DM Sans', sans-serif",
            boxSizing: "border-box",
          }} />
        <div style={{ display: "flex", gap: 6, marginTop: 10, justifyContent: "flex-end" }}>
          {alert != null && (
            <button onClick={onClear} style={{
              padding: "6px 12px", borderRadius: 5, border: "1px solid #fca5a5",
              background: "#fef2f2", color: "#dc2626", fontSize: 12, fontWeight: 600,
              cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
            }}>Remove</button>
          )}
          <button onClick={onClose} style={{
            padding: "6px 12px", borderRadius: 5, border: "1px solid #e2e8f0",
            background: "#fff", color: "#64748b", fontSize: 12, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Cancel</button>
          <button onClick={() => onSave(text)} style={{
            padding: "6px 12px", borderRadius: 5, border: "none",
            background: "#3b82f6", color: "#fff", fontSize: 12, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Save</button>
        </div>
      </div>
    </div>
  );
}

// â”€â”€ Auction Editor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BID_LEVELS = [1, 2, 3, 4, 5, 6, 7];
const BID_SUITS = ["C", "D", "H", "S", "NT"];
const SUIT_DISPLAY = { C: "â™£", D: "â™¦", H: "â™¥", S: "â™ ", NT: "NT" };
const SUIT_BTN_COLORS = { C: "#065f46", D: "#dc2626", H: "#dc2626", S: "#1e3a5f", NT: "#334155" };

function AuctionEditor({ auction, dealer, onSave, onClose }) {
  const [bids, setBids] = useState(() => auction.map(e => typeof e === "string" ? { bid: e } : { ...e }));

  // Determine what bids are legal (must be higher than last real bid)
  const lastRealBid = useMemo(() => {
    for (let i = bids.length - 1; i >= 0; i--) {
      const b = bids[i].bid;
      if (b !== "Pass" && b !== "Dbl" && b !== "Rdbl") return b;
    }
    return null;
  }, [bids]);

  const lastBidLevel = lastRealBid ? parseInt(lastRealBid[0]) : 0;
  const lastBidSuitIdx = lastRealBid ? BID_SUITS.indexOf(lastRealBid.slice(1)) : -1;

  const canBid = (level, suit) => {
    if (level > lastBidLevel) return true;
    if (level === lastBidLevel && BID_SUITS.indexOf(suit) > lastBidSuitIdx) return true;
    return false;
  };

  // Can double: last non-pass bid was by opponents (odd distance), not already doubled
  const canDbl = useMemo(() => {
    let dist = 0;
    for (let i = bids.length - 1; i >= 0; i--) {
      const b = bids[i].bid;
      if (b === "Pass") { dist++; continue; }
      if (b === "Dbl" || b === "Rdbl") return false;
      return dist % 2 === 0; // opponent's bid
    }
    return false;
  }, [bids]);

  const canRdbl = useMemo(() => {
    let dist = 0;
    for (let i = bids.length - 1; i >= 0; i--) {
      const b = bids[i].bid;
      if (b === "Pass") { dist++; continue; }
      if (b === "Rdbl") return false;
      if (b === "Dbl") return dist % 2 === 0;
      return false;
    }
    return false;
  }, [bids]);

  const addBid = (bid) => setBids(prev => [...prev, { bid }]);
  const removeLast = () => setBids(prev => prev.slice(0, -1));

  return (
    <div style={{
      position: "fixed", inset: 0, background: "rgba(15,23,42,0.5)",
      display: "flex", alignItems: "center", justifyContent: "center", zIndex: 100,
    }} onClick={(e) => { if (e.target === e.currentTarget) onClose(); }}>
      <div style={{
        background: "#fff", borderRadius: 12, padding: 20, width: 380,
        boxShadow: "0 12px 40px rgba(0,0,0,0.2)", fontFamily: "'DM Sans', sans-serif",
      }}>
        <div style={{ fontSize: 16, fontWeight: 700, color: "#0f172a", marginBottom: 12 }}>Edit Auction</div>

        {/* Current auction display */}
        <div style={{ marginBottom: 12, background: "#f8fafc", borderRadius: 8, padding: 8, minHeight: 50 }}>
          <AuctionDisplay auction={bids} dealer={dealer} compact />
        </div>

        {/* Bidding box grid */}
        <div style={{ display: "grid", gridTemplateColumns: "repeat(5, 1fr)", gap: 3, marginBottom: 10 }}>
          {BID_LEVELS.map(level => BID_SUITS.map(suit => {
            const bid = `${level}${suit}`;
            const enabled = canBid(level, suit);
            const suitColor = SUIT_BTN_COLORS[suit];
            return (
              <button key={bid} onClick={() => enabled && addBid(bid)} disabled={!enabled}
                style={{
                  padding: "6px 2px", borderRadius: 4, border: "1px solid #e2e8f0",
                  background: enabled ? "#fff" : "#f1f5f9", color: enabled ? suitColor : "#cbd5e1",
                  fontSize: 12, fontWeight: 700, cursor: enabled ? "pointer" : "default",
                  fontFamily: "'JetBrains Mono', monospace", opacity: enabled ? 1 : 0.4,
                }}>
                {level}{SUIT_DISPLAY[suit]}
              </button>
            );
          }))}
        </div>

        {/* Special bids */}
        <div style={{ display: "flex", gap: 6, marginBottom: 14 }}>
          <button onClick={() => addBid("Pass")} style={{
            flex: 1, padding: "8px", borderRadius: 5, border: "1px solid #e2e8f0",
            background: "#f0fdf4", color: "#16a34a", fontSize: 13, fontWeight: 700,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Pass</button>
          <button onClick={() => canDbl && addBid("Dbl")} disabled={!canDbl} style={{
            flex: 1, padding: "8px", borderRadius: 5, border: "1px solid #e2e8f0",
            background: canDbl ? "#fef2f2" : "#f8fafc", color: canDbl ? "#dc2626" : "#cbd5e1",
            fontSize: 13, fontWeight: 700, cursor: canDbl ? "pointer" : "default",
            fontFamily: "'DM Sans', sans-serif", opacity: canDbl ? 1 : 0.4,
          }}>Dbl</button>
          <button onClick={() => canRdbl && addBid("Rdbl")} disabled={!canRdbl} style={{
            flex: 1, padding: "8px", borderRadius: 5, border: "1px solid #e2e8f0",
            background: canRdbl ? "#eff6ff" : "#f8fafc", color: canRdbl ? "#2563eb" : "#cbd5e1",
            fontSize: 13, fontWeight: 700, cursor: canRdbl ? "pointer" : "default",
            fontFamily: "'DM Sans', sans-serif", opacity: canRdbl ? 1 : 0.4,
          }}>Rdbl</button>
          <button onClick={removeLast} disabled={bids.length === 0} style={{
            padding: "8px 12px", borderRadius: 5, border: "1px solid #e2e8f0",
            background: bids.length ? "#fff" : "#f8fafc", color: bids.length ? "#64748b" : "#cbd5e1",
            fontSize: 13, fontWeight: 700, cursor: bids.length ? "pointer" : "default",
            fontFamily: "'DM Sans', sans-serif",
          }}>âŒ«</button>
        </div>

        {/* Actions */}
        <div style={{ display: "flex", gap: 8, justifyContent: "flex-end" }}>
          <button onClick={onClose} style={{
            padding: "8px 16px", borderRadius: 6, border: "1px solid #e2e8f0",
            background: "#fff", color: "#64748b", fontSize: 13, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Cancel</button>
          <button onClick={() => { onSave(bids); onClose(); }} style={{
            padding: "8px 16px", borderRadius: 6, border: "none",
            background: "#3b82f6", color: "#fff", fontSize: 13, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Done</button>
        </div>
      </div>
    </div>
  );
}

// â”€â”€ Visibility Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function VisibilityToggle({ visibility, onChange }) {
  const toggle = (seat) => {
    const next = visibility.includes(seat)
      ? visibility.replace(seat, "")
      : SEATS.filter(s => s === seat || visibility.includes(s)).join("");
    onChange(next || "");
  };
  return (
    <div style={{ display: "flex", gap: 3 }}>
      {SEATS.map(seat => (
        <button key={seat} onClick={() => toggle(seat)} style={{
          width: 28, height: 28, borderRadius: 5, border: "none",
          fontWeight: 700, fontSize: 12, cursor: "pointer",
          fontFamily: "'DM Sans', sans-serif",
          background: visibility.includes(seat) ? "#3b82f6" : "#f1f5f9",
          color: visibility.includes(seat) ? "#fff" : "#94a3b8",
          transition: "all 0.12s ease",
        }}>{seat}</button>
      ))}
    </div>
  );
}

// â”€â”€ Tag Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function TagToolbar({ onInsert, textareaRef }) {
  const [expandedTag, setExpandedTag] = useState(null);
  const [tagValue, setTagValue] = useState("");
  const insertAtCursor = (tagText) => {
    const ta = textareaRef.current;
    if (!ta) { onInsert(tagText, 0); return; }
    const start = ta.selectionStart;
    const end = ta.selectionEnd;
    const text = ta.value;
    onInsert(text.slice(0, start) + tagText + text.slice(end), start + tagText.length);
  };
  const tagBtn = (label, color, bg) => ({
    padding: "3px 8px", borderRadius: 4, border: "none",
    background: bg, color, fontSize: 11, fontWeight: 700,
    cursor: "pointer", fontFamily: "'JetBrains Mono', monospace",
  });
  const handleSubmit = () => {
    if (!tagValue.trim()) return;
    const tag = expandedTag === "BID" ? `[BID ${tagValue.trim()}]`
      : expandedTag === "CARD" ? `[choose-card ${tagValue.trim()}]`
      : expandedTag === "PLAY" ? `[PLAY ${tagValue.trim()}]`
      : expandedTag === "SHOWCARDS" ? `[showcards ${tagValue.trim()}]`
      : "";
    if (tag) insertAtCursor(tag);
    setTagValue(""); setExpandedTag(null);
  };
  if (expandedTag) {
    const ph = { BID: "e.g. 3\\H", CARD: "e.g. SQ or any:S9,S4", PLAY: "e.g. S:H5", SHOWCARDS: "e.g. E:S7 S:S5" };
    return (
      <div style={{ display: "flex", gap: 4, alignItems: "center", flexWrap: "wrap" }}>
        <span style={{ fontSize: 11, fontWeight: 600, color: "#64748b" }}>{expandedTag}:</span>
        <input autoFocus value={tagValue} onChange={e => setTagValue(e.target.value)}
          onKeyDown={e => { if (e.key === "Enter") handleSubmit(); if (e.key === "Escape") setExpandedTag(null); }}
          placeholder={ph[expandedTag]}
          style={{ width: 140, padding: "3px 6px", borderRadius: 4, border: "1px solid #cbd5e1", fontSize: 12, fontFamily: "'JetBrains Mono', monospace" }}
        />
        <button onClick={handleSubmit} style={tagBtn("âœ“", "#065f46", "#d1fae5")}>Insert</button>
        <button onClick={() => setExpandedTag(null)} style={tagBtn("Ã—", "#64748b", "#f1f5f9")}>Cancel</button>
      </div>
    );
  }
  return (
    <div style={{ display: "flex", gap: 3, flexWrap: "wrap", alignItems: "center" }}>
      <span style={{ fontSize: 10, color: "#94a3b8", fontWeight: 600, marginRight: 2 }}>Tags:</span>
      <button onClick={() => setExpandedTag("BID")} style={tagBtn("BID", "#92400e", "#fef3c7")}>BID</button>
      <button onClick={() => setExpandedTag("CARD")} style={tagBtn("choose-card", "#065f46", "#d1fae5")}>CARD</button>
      <button onClick={() => setExpandedTag("PLAY")} style={tagBtn("PLAY", "#1e40af", "#dbeafe")}>PLAY</button>
      <button onClick={() => setExpandedTag("SHOWCARDS")} style={tagBtn("showcards", "#6b21a8", "#f3e8ff")}>SHOWCARDS</button>
      <button onClick={() => insertAtCursor("[NEXT]")} style={tagBtn("NEXT", "#475569", "#f1f5f9")}>NEXT</button>
      <button onClick={() => insertAtCursor("[ROTATE]")} style={tagBtn("ROTATE", "#475569", "#f1f5f9")}>ROTATE</button>
    </div>
  );
}

// â”€â”€ Highlighted Textarea (overlay approach) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TAG_HIGHLIGHT_STYLES = {
  BID: { color: "#92400e", background: "#fef3c7" },
  "choose-card": { color: "#065f46", background: "#d1fae5" },
  PLAY: { color: "#1e40af", background: "#dbeafe" },
  showcards: { color: "#6b21a8", background: "#f3e8ff" },
  NEXT: { color: "#475569", background: "#f1f5f9" },
  ROTATE: { color: "#475569", background: "#f1f5f9" },
  show: { color: "#475569", background: "#f1f5f9" },
};
const TAG_RE = /\[(BID|choose-card|PLAY|showcards|NEXT|ROTATE|show)(\s[^\]]*)?\]/gi;

function HighlightedTextarea({ value, onChange, placeholder, textareaRef, style }) {
  const backdropRef = useRef(null);
  const handleScroll = (e) => {
    if (backdropRef.current) {
      backdropRef.current.scrollTop = e.target.scrollTop;
      backdropRef.current.scrollLeft = e.target.scrollLeft;
    }
  };
  const highlighted = useMemo(() => {
    let html = value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    html = html.replace(TAG_RE, (match, tag, rest) => {
      const key = Object.keys(TAG_HIGHLIGHT_STYLES).find(k => k.toLowerCase() === tag.toLowerCase());
      const s = key ? TAG_HIGHLIGHT_STYLES[key] : null;
      if (!s) return match;
      return `<span style="color:${s.color};background:${s.background};border-radius:3px;padding:0 2px;font-weight:600">${match}</span>`;
    });
    // Color suit symbols: hearts/diamonds red, spades/clubs dark
    html = html.replace(/\\([SsHhDdCc])/g, (match, ch) => {
      const u = ch.toUpperCase();
      const sym = { S: "\u2660", H: "\u2665", D: "\u2666", C: "\u2663" }[u];
      const color = (u === "H" || u === "D") ? "#c0392b" : "#1a3a5c";
      return `<span style="color:${color};font-weight:600">${sym}</span>`;
    });
    if (html.endsWith("\n")) html += " ";
    return html;
  }, [value]);
  const shared = {
    fontSize: style.fontSize, fontFamily: style.fontFamily, lineHeight: style.lineHeight,
    padding: style.padding, boxSizing: "border-box", whiteSpace: "pre-wrap", wordWrap: "break-word",
    overflowWrap: "break-word", letterSpacing: "normal", tabSize: 4,
  };
  return (
    <div style={{ position: "relative", width: "100%", height: "100%", minHeight: style.minHeight }}>
      <div ref={backdropRef} dangerouslySetInnerHTML={{ __html: highlighted }} style={{
        ...shared, position: "absolute", top: 0, left: 0, right: 0, bottom: 0,
        overflow: "hidden", pointerEvents: "none", color: "#1e293b",
        background: style.background || "#fafbfc",
        borderRadius: style.borderRadius, border: style.border,
      }} />
      <textarea ref={textareaRef} value={value} onChange={onChange} onScroll={handleScroll}
        placeholder={placeholder} style={{
        ...shared, width: "100%", height: "100%", minHeight: style.minHeight,
        position: "relative", color: "transparent", caretColor: "#1e293b",
        background: "transparent", borderRadius: style.borderRadius,
        border: style.border, resize: style.resize,
        outline: "none",
      }} />
    </div>
  );
}

// â”€â”€ Filtered Combo Box â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function FilteredCombo({ value, onChange, options, placeholder, label }) {
  const [open, setOpen] = useState(false);
  const [filter, setFilter] = useState("");
  const ref = useRef(null);

  useEffect(() => {
    const handler = (e) => {
      if (ref.current && !ref.current.contains(e.target)) setOpen(false);
    };
    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, []);

  const filtered = useMemo(() => {
    if (!filter) return options;
    const lower = filter.toLowerCase();
    return options.filter(o => o.toLowerCase().includes(lower));
  }, [options, filter]);

  const displayValue = value || "";
  // Show the last segment of a path nicely
  const formatOption = (opt) => {
    if (opt.includes("/")) {
      const parts = opt.split("/");
      return (
        <span>
          <span style={{ color: "#94a3b8", fontSize: 10 }}>{parts.slice(0, -1).join("/")}/</span>
          <span style={{ fontWeight: 600 }}>{parts[parts.length - 1].replace(/_/g, " ")}</span>
        </span>
      );
    }
    return opt;
  };

  return (
    <div ref={ref} style={{ position: "relative" }}>
      <input
        value={open ? filter : displayValue}
        onChange={(e) => { setFilter(e.target.value); if (!open) setOpen(true); }}
        onFocus={() => { setOpen(true); setFilter(""); }}
        placeholder={placeholder}
        style={{
          width: "100%", padding: "4px 8px", borderRadius: 4,
          border: open ? "1.5px solid #3b82f6" : "1px solid #cbd5e1",
          fontSize: 12, fontFamily: "'DM Sans', sans-serif",
          color: "#1e293b", boxSizing: "border-box",
          background: "#fff",
        }}
      />
      {open && (
        <div style={{
          position: "absolute", top: "100%", left: 0, right: 0,
          maxHeight: 200, overflow: "auto", background: "#fff",
          border: "1px solid #e2e8f0", borderRadius: "0 0 6px 6px",
          boxShadow: "0 8px 24px rgba(0,0,0,0.12)", zIndex: 50,
        }}>
          {filtered.length === 0 && filter && (
            <div
              onClick={() => { onChange(filter); setOpen(false); setFilter(""); }}
              style={{
                padding: "6px 10px", fontSize: 12, cursor: "pointer",
                color: "#3b82f6", fontStyle: "italic",
              }}
            >
              Use "{filter}"
            </div>
          )}
          {filtered.map((opt, i) => (
            <div
              key={i}
              onClick={() => { onChange(opt); setOpen(false); setFilter(""); }}
              style={{
                padding: "5px 10px", fontSize: 12, cursor: "pointer",
                background: opt === value ? "#eff6ff" : "transparent",
                fontFamily: "'DM Sans', sans-serif",
                borderBottom: i < filtered.length - 1 ? "1px solid #f1f5f9" : "none",
              }}
              onMouseEnter={e => { e.currentTarget.style.background = "#f8fafc"; }}
              onMouseLeave={e => { e.currentTarget.style.background = opt === value ? "#eff6ff" : "transparent"; }}
            >
              {formatOption(opt)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

// â”€â”€ Board Navigator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function BoardNav({ boards, activeIdx, onSelect, includedCount }) {
  return (
    <div style={{
      display: "flex", alignItems: "center", gap: 4, padding: "6px 12px",
      background: "#0f172a", borderBottom: "1px solid #1e293b",
      overflowX: "auto",
    }}>
      <div style={{ display: "flex", gap: 3, flex: 1, overflowX: "auto" }}>
        {boards.map((b, i) => {
          const hasScenes = b.scenes && b.scenes.some(s => s.text.trim());
          const hasCommentary = b.commentary && b.commentary.trim();
          const skipped = !b.included;
          return (
            <button key={i} onClick={() => onSelect(i)} style={{
              padding: "4px 10px", borderRadius: 4, border: "none",
              background: i === activeIdx ? "#3b82f6" : skipped ? "#0f172a" : "#1e293b",
              color: i === activeIdx ? "#fff" : skipped ? "#475569" : "#94a3b8",
              fontSize: 11, fontWeight: 600, cursor: "pointer", whiteSpace: "nowrap",
              fontFamily: "'DM Sans', sans-serif",
              position: "relative",
              opacity: skipped && i !== activeIdx ? 0.5 : 1,
              textDecoration: skipped ? "line-through" : "none",
            }}>
              {b.board ? `#${b.board}` : `${i + 1}`}
              {(hasScenes || hasCommentary) && (
                <span style={{
                  position: "absolute", top: 1, right: 1,
                  width: 5, height: 5, borderRadius: "50%",
                  background: hasScenes ? "#22c55e" : "#f59e0b",
                }} />
              )}
            </button>
          );
        })}
      </div>
      <span style={{
        fontSize: 10, color: "#64748b", fontWeight: 600, whiteSpace: "nowrap",
        fontFamily: "'DM Sans', sans-serif", marginLeft: 8,
      }}>
        {includedCount} of {boards.length} included
      </span>
    </div>
  );
}

// â”€â”€ Scene Mini-card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function extractTagsFromText(text) {
  const tags = [];
  const re = /\[(BID|choose-card|PLAY|ROTATE)\s*([^\]]*)\]/gi;
  let m;
  while ((m = re.exec(text)) !== null) {
    const type = m[1].toUpperCase() === "CHOOSE-CARD" ? "CARD" : m[1].toUpperCase();
    tags.push({ type, value: m[2].trim() || "" });
  }
  return tags;
}

function SceneMiniCard({ scene, index, isActive, onClick, onRemove, canRemove }) {
  const hasContent = scene.text.trim().length > 0;
  const textTags = extractTagsFromText(scene.text);
  const hasPrompts = textTags.length > 0;
  return (
    <div onClick={onClick} style={{
      padding: "8px 10px", borderRadius: 6, cursor: "pointer",
      background: isActive ? "#eff6ff" : "#fff",
      border: isActive ? "2px solid #3b82f6" : "1.5px solid #e2e8f0",
      transition: "all 0.12s ease", position: "relative",
    }}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 4 }}>
        <span style={{ fontSize: 10, fontWeight: 700, color: isActive ? "#3b82f6" : "#94a3b8", fontFamily: "'DM Sans', sans-serif" }}>
          SCENE {index + 1}
        </span>
        <div style={{ display: "flex", gap: 2 }}>
          {scene.visibility.split("").map(s => (
            <span key={s} style={{ fontSize: 9, fontWeight: 700, padding: "1px 3px", borderRadius: 2, background: "#dbeafe", color: "#1e40af" }}>{s}</span>
          ))}
        </div>
      </div>
      <div style={{
        fontSize: 11, color: hasContent ? "#475569" : "#94a3b8",
        lineHeight: 1.3, maxHeight: 36, overflow: "hidden",
        fontStyle: hasContent ? "normal" : "italic",
      }}>
        {hasContent ? formatText(scene.text.trim()).substring(0, 80) + (scene.text.length > 80 ? "â€¦" : "") : (scene.hint || "Empty scene")}
      </div>
      {hasPrompts && (
        <div style={{ display: "flex", gap: 2, marginTop: 4, flexWrap: "wrap" }}>
          {textTags.map((p, j) => (
            <span key={j} style={{
              fontSize: 9, fontWeight: 700, padding: "1px 4px", borderRadius: 3,
              background: p.type === "BID" ? "#fef3c7" : p.type === "CARD" ? "#d1fae5" : "#f1f5f9",
              color: p.type === "BID" ? "#92400e" : p.type === "CARD" ? "#065f46" : "#475569",
              fontFamily: "'JetBrains Mono', monospace",
            }}>{p.type}{p.value ? ` ${p.value}` : ""}</span>
          ))}
        </div>
      )}
      {canRemove && (
        <button onClick={(e) => { e.stopPropagation(); onRemove(); }} style={{
          position: "absolute", top: 4, right: 4, width: 16, height: 16,
          borderRadius: "50%", border: "none", background: "#fee2e2",
          color: "#dc2626", fontSize: 10, fontWeight: 700, cursor: "pointer",
          display: "flex", alignItems: "center", justifyContent: "center", opacity: 0.6,
        }}>Ã—</button>
      )}
    </div>
  );
}

// â”€â”€ Template Picker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function TemplatePicker({ onSelect, onClose, stickyTemplate }) {
  return (
    <div style={{
      position: "fixed", inset: 0, background: "rgba(15,23,42,0.6)",
      display: "flex", alignItems: "center", justifyContent: "center", zIndex: 100,
    }}>
      <div style={{
        background: "#fff", borderRadius: 12, padding: 24, maxWidth: 560, width: "90%",
        boxShadow: "0 25px 50px rgba(0,0,0,0.25)",
      }}>
        <div style={{ fontSize: 18, fontWeight: 700, color: "#0f172a", marginBottom: 4, fontFamily: "'Crimson Pro', serif" }}>
          Choose Lesson Template
        </div>
        <div style={{ fontSize: 13, color: "#64748b", marginBottom: 16 }}>
          Sets visibility presets for this board. Existing text is preserved.
          {stickyTemplate && (
            <span style={{ display: "block", marginTop: 4, color: "#3b82f6", fontWeight: 600 }}>
              Current default: {TEMPLATES[stickyTemplate]?.name} (applied to new boards automatically)
            </span>
          )}
        </div>
        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 8 }}>
          {Object.entries(TEMPLATES).map(([key, tmpl]) => (
            <button key={key} onClick={() => onSelect(key)} style={{
              padding: "12px 14px", borderRadius: 8,
              border: key === stickyTemplate ? "2px solid #3b82f6" : "1.5px solid #e2e8f0",
              background: key === stickyTemplate ? "#eff6ff" : "#fff",
              cursor: "pointer", textAlign: "left", transition: "all 0.12s ease",
            }}
              onMouseEnter={e => { e.currentTarget.style.borderColor = "#3b82f6"; }}
              onMouseLeave={e => { e.currentTarget.style.borderColor = key === stickyTemplate ? "#3b82f6" : "#e2e8f0"; }}
            >
              <div style={{ fontSize: 16, marginBottom: 4 }}>{tmpl.icon}</div>
              <div style={{ fontSize: 14, fontWeight: 700, color: "#0f172a" }}>{tmpl.name}</div>
              <div style={{ fontSize: 12, color: "#64748b", marginTop: 2 }}>{tmpl.desc}</div>
              <div style={{ fontSize: 11, color: "#94a3b8", marginTop: 4 }}>
                {tmpl.scenes.length} scene{tmpl.scenes.length > 1 ? "s" : ""} Â· Student {SEAT_NAMES[tmpl.defaultStudent]}
              </div>
            </button>
          ))}
        </div>
        <button onClick={onClose} style={{
          marginTop: 16, padding: "8px 16px", borderRadius: 6,
          border: "1px solid #cbd5e1", background: "#f8fafc",
          fontSize: 13, fontWeight: 600, cursor: "pointer", color: "#64748b",
          fontFamily: "'DM Sans', sans-serif",
        }}>Cancel</button>
      </div>
    </div>
  );
}

// â”€â”€ Preview Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Build a flat list of steps from all scenes. Pauses at [BID], [choose-card], [NEXT].
// [show X] changes visibility silently. Scene boundaries without [NEXT] flow automatically.
function buildPreviewSteps(scenes) {
  const fullText = scenes.map(s => s.text).join("\n");
  const steps = [];
  let lastIndex = 0;
  let currentVis = scenes[0]?.visibility || "NESW";
  const re = /\[(BID|choose-card|NEXT)\s*([^\]]*)\]/gi;
  let m;
  while ((m = re.exec(fullText)) !== null) {
    const textBefore = fullText.slice(lastIndex, m.index);
    // Update visibility from any [show X] in this chunk
    const showMatches = [...textBefore.matchAll(/\[show\s+([NESW]+)\]/gi)];
    if (showMatches.length > 0) currentVis = showMatches[showMatches.length - 1][1].toUpperCase();
    const rawType = m[1].toUpperCase();
    const type = rawType === "CHOOSE-CARD" ? "CARD" : rawType;
    steps.push({
      text: textBefore,
      pause: { type, value: (m[2] || "").trim() },
      visibility: currentVis,
    });
    lastIndex = m.index + m[0].length;
  }
  // Remaining text after last pause
  const remaining = fullText.slice(lastIndex);
  const showMatches = [...remaining.matchAll(/\[show\s+([NESW]+)\]/gi)];
  if (showMatches.length > 0) currentVis = showMatches[showMatches.length - 1][1].toUpperCase();
  steps.push({ text: remaining, pause: null, visibility: currentVis });
  return steps;
}

// Strip structural tags from display text (but not [BID]/[choose-card]/[NEXT] â€” those are already consumed)
function stripDisplayTags(text) {
  return text.replace(/\[(show|ROTATE|showcards)(\s[^\]]*)?\]/gi, "").trim();
}

function PreviewMode({ board, onClose }) {
  const [stepIdx, setStepIdx] = useState(0);
  const scenes = board.scenes || [];
  const steps = useMemo(() => buildPreviewSteps(scenes), [scenes]);
  const step = steps[stepIdx] || steps[0];
  if (!step) return null;

  const currentPause = step.pause;

  // Prior steps text (dimmed) and current step text (normal)
  const priorText = stripDisplayTags(steps.slice(0, stepIdx).map(s => s.text).join(""));
  const currentText = stripDisplayTags(step.text);

  // Count resolved BID pauses before current step
  const resolvedBids = useMemo(() => {
    let count = 0;
    for (let i = 0; i < stepIdx; i++) {
      if (steps[i].pause && steps[i].pause.type === "BID") count++;
    }
    return count;
  }, [steps, stepIdx]);

  // Build progressive auction: show bids up to current point, "?" for pending student bid
  const isAtBidPause = currentPause && currentPause.type === "BID";
  const totalBidPauses = useMemo(() => steps.filter(s => s.pause && s.pause.type === "BID").length, [steps]);
  const allBidsResolved = resolvedBids >= totalBidPauses;
  const progressiveAuction = useMemo(() => {
    if (!board.auction || !board.auction.length) return [];
    if (allBidsResolved) return board.auction; // show full auction after all BID pauses resolved
    const studentSeat = board.student || "S";
    const dealerIdx = SEATS.indexOf(board.dealer);
    let studentBidsSeen = 0;
    const result = [];
    for (let i = 0; i < board.auction.length; i++) {
      const seat = SEATS[(dealerIdx + i) % 4];
      if (seat === studentSeat) {
        if (studentBidsSeen < resolvedBids) {
          result.push(board.auction[i]);
          studentBidsSeen++;
        } else if (isAtBidPause) {
          result.push("?");
          break;
        } else {
          break;
        }
      } else {
        result.push(board.auction[i]);
      }
    }
    return result;
  }, [board.auction, board.dealer, board.student, resolvedBids, isAtBidPause, allBidsResolved]);

  const canPrev = stepIdx > 0;
  const isEnd = stepIdx >= steps.length - 1 && !currentPause;

  function advance() {
    if (stepIdx < steps.length - 1) setStepIdx(stepIdx + 1);
  }

  function goBack() {
    if (stepIdx > 0) setStepIdx(stepIdx - 1);
  }

  // Pause button styles
  const pauseBtnStyles = {
    BID: {
      background: "linear-gradient(135deg, #f59e0b, #d97706)",
      boxShadow: "0 2px 8px rgba(245,158,11,0.3)",
    },
    CARD: {
      background: "linear-gradient(135deg, #10b981, #059669)",
      boxShadow: "0 2px 8px rgba(16,185,129,0.3)",
    },
    NEXT: {
      background: "linear-gradient(135deg, #3b82f6, #6366f1)",
      boxShadow: "none",
    },
  };
  const pauseStyle = currentPause ? (pauseBtnStyles[currentPause.type] || pauseBtnStyles.NEXT) : {};

  const pauseLabel = currentPause
    ? currentPause.type === "BID" ? formatText("BID " + currentPause.value)
    : currentPause.type === "CARD" ? formatText("Play " + currentPause.value)
    : "NEXT"
    : "";

  return (
    <div style={{
      position: "fixed", inset: 0, background: "rgba(15,23,42,0.85)",
      display: "flex", alignItems: "center", justifyContent: "center", zIndex: 100,
    }}>
      <div style={{
        background: "#fff", borderRadius: 12, maxWidth: 800, width: "95%",
        maxHeight: "90vh", overflow: "auto",
        boxShadow: "0 25px 50px rgba(0,0,0,0.4)",
      }}>
        {/* Preview header */}
        <div style={{
          padding: "12px 20px", background: "#0f172a",
          display: "flex", alignItems: "center", justifyContent: "space-between",
          borderRadius: "12px 12px 0 0",
        }}>
          <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
            <span style={{ fontSize: 14, fontWeight: 700, color: "#f8fafc", fontFamily: "'Crimson Pro', serif" }}>
              Student Preview
            </span>
            <span style={{ fontSize: 11, color: "#64748b", fontWeight: 600 }}>
              Board {board.board || "â€”"}
            </span>
          </div>
          <button onClick={onClose} style={{
            padding: "4px 12px", borderRadius: 4, border: "1px solid #475569",
            background: "transparent", color: "#94a3b8", fontSize: 12, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Close</button>
        </div>

        {/* Board view â€” visibility updates from [show] tags */}
        <div style={{ padding: "16px 20px" }}>
          <BoardDiagram hands={board.hands} visibility={step.visibility} compact hideInvisible />
        </div>

        {/* Auction â€” progressive */}
        {progressiveAuction.length > 0 && (
          <div style={{ padding: "0 20px 12px", maxWidth: 300, margin: "0 auto" }}>
            <AuctionDisplay auction={progressiveAuction} dealer={board.dealer} compact />
          </div>
        )}

        {/* Narrative â€” prior text dimmed, current text normal */}
        <div style={{
          padding: "16px 24px", margin: "0 20px",
          background: "#f8fafc", borderRadius: 8, border: "1px solid #e2e8f0",
          fontSize: 15, lineHeight: 1.7,
          fontFamily: "'DM Sans', sans-serif",
          whiteSpace: "pre-wrap",
          minHeight: 60,
        }}>
          {priorText && (
            <span style={{ color: "#9ca3af" }}><FormattedText text={priorText} dimmed />{"\n"}</span>
          )}
          {currentText ? (
            <span style={{ color: "#1e293b" }}><FormattedText text={currentText} /></span>
          ) : (!priorText && <em style={{ color: "#94a3b8" }}>No narrative for this step.</em>)}
        </div>

        {/* Navigation */}
        <div style={{
          padding: "16px 20px", display: "flex", justifyContent: "center", gap: 12,
          borderTop: "1px solid #e2e8f0",
        }}>
          <button onClick={goBack} disabled={!canPrev}
            style={{
              padding: "8px 20px", borderRadius: 6, border: "1px solid #cbd5e1",
              background: canPrev ? "#fff" : "#f8fafc",
              color: canPrev ? "#475569" : "#cbd5e1",
              fontSize: 13, fontWeight: 600, cursor: canPrev ? "pointer" : "default",
              fontFamily: "'DM Sans', sans-serif",
            }}>â† Previous</button>
          {currentPause ? (
            <button onClick={advance} style={{
              padding: "8px 24px", borderRadius: 8, border: "none",
              color: "#fff", fontWeight: 700,
              fontSize: currentPause.type === "NEXT" ? 13 : 15,
              fontFamily: currentPause.type === "NEXT" ? "'DM Sans', sans-serif" : "'JetBrains Mono', monospace",
              cursor: "pointer",
              ...pauseStyle,
            }}>{pauseLabel}{currentPause.type === "NEXT" ? " â†’" : ""}</button>
          ) : (
            <button disabled={isEnd}
              style={{
                padding: "8px 20px", borderRadius: 6, border: "none",
                background: "#f1f5f9",
                color: "#cbd5e1",
                fontSize: 13, fontWeight: 600, cursor: "default",
                fontFamily: "'DM Sans', sans-serif",
              }}>End</button>
          )}
        </div>
      </div>
    </div>
  );
}

// â”€â”€ Main App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function BridgeCurator() {
  const [boards, setBoards] = useState([]);
  const [activeBoard, setActiveBoard] = useState(0);
  const [activeScene, setActiveScene] = useState(0);
  const [showTemplatePicker, setShowTemplatePicker] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [showRaw, setShowRaw] = useState(false);
  const [showAuctionEditor, setShowAuctionEditor] = useState(false);
  const [alertBidIdx, setAlertBidIdx] = useState(null); // index into auction for alert dialog
  const [dirty, setDirty] = useState(false);
  const [stickyTemplate, setStickyTemplate] = useState(null);
  const [stickyCategory, setStickyCategory] = useState("");
  const [stickyDifficulty, setStickyDifficulty] = useState("");
  const [stickySkillPath, setStickySkillPath] = useState("");
  const fileInputRef = useRef(null);
  const textareaRef = useRef(null);

  const board = boards[activeBoard] || null;
  const currentScene = board?.scenes?.[activeScene] || null;
  const includedCount = boards.filter(b => b.included).length;

  const ensureScenes = useCallback((b) => {
    if (b.scenes) return b;
    if (b.commentary && b.commentary.trim()) return { ...b, scenes: parseCommentary(b.commentary) };
    return { ...b, scenes: [{ text: "", visibility: "NESW", showcards: [], hint: "" }] };
  }, []);

  // â”€â”€ Auto-generate bidding commentary from auction â”€â”€â”€â”€â”€â”€â”€
  const generateBiddingCommentary = useCallback((b) => {
    const auction = b.auction || [];
    const student = b.student || "S";
    const dealerIdx = SEATS.indexOf(b.dealer || "N");
    if (auction.length === 0) return null;

    // Figure out partner/LHO/RHO relative to student
    const studentIdx = SEATS.indexOf(student);
    const partnerIdx = (studentIdx + 2) % 4;
    const lhoIdx = (studentIdx + 1) % 4;
    const rhoIdx = (studentIdx + 3) % 4;
    const partner = SEATS[partnerIdx];
    const lho = SEATS[lhoIdx];
    const rho = SEATS[rhoIdx];

    // Format a bid for display in commentary text
    const fmtBid = (bid) => {
      if (bid === "Pass") return "passes";
      if (bid === "Dbl") return "doubles";
      if (bid === "Rdbl") return "redoubles";
      return bid
        .replace(/(\d)S/g, "$1\\S").replace(/(\d)H/g, "$1\\H")
        .replace(/(\d)D/g, "$1\\D").replace(/(\d)C/g, "$1\\C")
        .replace(/(\d)NT/g, "$1NT");
    };

    // Format a bid for a [BID] tag
    const fmtBidTag = (bid) => {
      if (bid === "Pass") return "Pass";
      if (bid === "Dbl") return "Dbl";
      if (bid === "Rdbl") return "Rdbl";
      return bid
        .replace(/(\d)S/g, "$1\\S").replace(/(\d)H/g, "$1\\H")
        .replace(/(\d)D/g, "$1\\D").replace(/(\d)C/g, "$1\\C");
    };

    const seatName = (idx) => SEAT_NAMES[SEATS[idx]];
    const seatRelation = (idx) => {
      if (idx === partnerIdx) return "Partner";
      if (idx === lhoIdx) return "LHO (" + seatName(idx) + ")";
      if (idx === rhoIdx) return "RHO (" + seatName(idx) + ")";
      return seatName(idx);
    };

    const scenes = [];
    let narrative = "";
    let studentBidCount = 0;
    const studentVis = student; // show only student hand

    // Walk through auction
    for (let i = 0; i < auction.length; i++) {
      const entry = auction[i];
      const bid = typeof entry === "string" ? entry : entry.bid;
      const bidderIdx = (dealerIdx + i) % 4;
      const isStudent = bidderIdx === studentIdx;

      if (bid === "Pass" && !isStudent) {
        // Skip opponent passes (assumed); only narrate partner passes
        if (bidderIdx === partnerIdx) {
          if (narrative) narrative += " ";
          narrative += `Partner ${fmtBid(bid)}.`;
        }
        continue;
      }

      if (!isStudent) {
        // Non-student bid (not a pass) â€” narrate it
        if (narrative) narrative += " ";
        if (bidderIdx === partnerIdx) {
          if (studentBidCount === 0 && i < 4) {
            // Partner's opening bid
            narrative += `Partner opens ${fmtBid(bid)}.`;
          } else {
            narrative += `Partner bids ${fmtBid(bid)}.`;
          }
        } else {
          narrative += `${seatRelation(bidderIdx)} bids ${fmtBid(bid)}.`;
        }
        continue;
      }

      // Student's bid â€” create a scene
      studentBidCount++;
      if (narrative) narrative += " ";

      if (bid === "Pass" && studentBidCount > 1) {
        narrative += "What do you bid?[BID Pass]";
      } else {
        narrative += `What do you bid?[BID ${fmtBidTag(bid)}]`;
      }
      const showPrefix = studentBidCount === 1 ? `[show ${studentVis}]\n` : "";
      scenes.push({
        visibility: studentVis, text: showPrefix + narrative,
        showcards: [], hint: "",
      });
      narrative = "";
    }

    // Final reveal scene
    scenes.push({
      visibility: "NESW",
      text: "[show NESW]\n\n",
      showcards: [],
      hint: "Explain the bidding and the final contract.",
    });

    return scenes;
  }, []);

  // â”€â”€ Apply sticky template to a board (merge behavior) â”€â”€â”€â”€
  const applyTemplateToBoard = useCallback((b, templateKey) => {
    const tmpl = TEMPLATES[templateKey];
    if (!tmpl) return b;
    const existingScenes = b.scenes || [];
    const hasExistingContent = existingScenes.some(s => s.text.trim());
    const hasRawCommentary = !hasExistingContent && b.commentary && b.commentary.trim();
    const contentScenes = hasRawCommentary ? (parseCommentary(b.commentary) || existingScenes) : existingScenes;

    let mergedScenes;
    // Determine which seats actually have cards (for "show all" scenes)
    const populatedSeats = SEATS.filter(s => b.hands && b.hands[s] && b.hands[s].length > 0).join("");
    const revealVis = populatedSeats || "NESW";

    if (hasExistingContent || hasRawCommentary) {
      // Merge: overlay template visibility/hints onto existing content
      const tmplScenes = tmpl.scenes;
      mergedScenes = [];
      const maxLen = Math.max(contentScenes.length, tmplScenes.length);
      for (let i = 0; i < maxLen; i++) {
        const existing = contentScenes[i];
        const template = tmplScenes[Math.min(i, tmplScenes.length - 1)];
        if (existing) {
          // Use template visibility, but limit "NESW" to only populated seats
          let newVis = i < tmplScenes.length ? tmplScenes[i].visibility : template.visibility;
          if (newVis === "NESW") newVis = revealVis;
          // Update the [show X] tag in text to match the new visibility
          let newText = existing.text;
          if (/\[show\s+[NESW]+\]/i.test(newText)) {
            newText = newText.replace(/\[show\s+[NESW]+\]/i, `[show ${newVis}]`);
          }
          mergedScenes.push({
            ...existing,
            text: newText,
            visibility: newVis,
            hint: i < tmplScenes.length ? tmplScenes[i].hint : "",
          });
        } else {
          let vis = template.visibility === "NESW" ? revealVis : template.visibility;
          mergedScenes.push({ ...template, visibility: vis, text: `[show ${vis}]\n`, showcards: [...template.showcards] });
        }
      }
    } else if (templateKey === "bidding" && b.auction && b.auction.length > 0) {
      // No content â€” auto-generate bidding commentary from auction
      const autoScenes = generateBiddingCommentary(b);
      if (autoScenes) {
        // Replace NESW with only populated seats in reveal scene
        mergedScenes = autoScenes.map(s => {
          const vis = s.visibility === "NESW" ? revealVis : s.visibility;
          const text = s.text.replace(/\[show\s+NESW\]/i, `[show ${revealVis}]`);
          return { ...s, visibility: vis, text };
        });
      } else {
        mergedScenes = tmpl.scenes.map(s => {
          const vis = s.visibility === "NESW" ? revealVis : s.visibility;
          return { ...s, visibility: vis, text: `[show ${vis}]\n`, showcards: [...s.showcards] };
        });
      }
    } else {
      // No content, no auction or non-bidding template â€” use template defaults
      mergedScenes = tmpl.scenes.map(s => {
        const vis = s.visibility === "NESW" ? revealVis : s.visibility;
        return { ...s, visibility: vis, text: `[show ${vis}]\n`, showcards: [...s.showcards] };
      });
    }
    return {
      ...b,
      scenes: mergedScenes,
      student: b.student || tmpl.defaultStudent,
      templateKey,
    };
  }, [generateBiddingCommentary]);

  // â”€â”€ File handling with File System Access API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [sourceFileHandle, setSourceFileHandle] = useState(null);
  const [workingFileHandle, setWorkingFileHandle] = useState(null);
  const [fileName, setFileName] = useState("");
  const [fileSystemWorks, setFileSystemWorks] = useState(false);
  const hasFileSystemAPI = typeof window !== "undefined" && "showOpenFilePicker" in window;

  // Open source file
  const handleOpen = useCallback(async () => {
    if (hasFileSystemAPI) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{ description: "PBN Files", accept: { "text/plain": [".pbn", ".txt"] } }],
        });
        const file = await handle.getFile();
        const text = await file.text();
        const parsed = parsePBNFile(text);
        const withScenes = parsed.map(b => ensureScenes(b));
        setBoards(withScenes);
        setActiveBoard(0);
        setActiveScene(0);
        setDirty(false);
        setStickyTemplate(null);
        setSourceFileHandle(handle);
        setWorkingFileHandle(null);
        setFileName(file.name);
        setFileSystemWorks(true); // confirmed FSAPI works in this context
        return;
      } catch (e) {
        if (e.name === "AbortError") return;
        // Fall through to file input if API fails (e.g. sandbox)
        console.log("File System Access API unavailable, using fallback");
      }
    }
    fileInputRef.current?.click();
  }, [hasFileSystemAPI, ensureScenes]);

  // Fallback file input handler
  const handleImport = useCallback((e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      const parsed = parsePBNFile(ev.target.result);
      const withScenes = parsed.map(b => ensureScenes(b));
      setBoards(withScenes);
      setActiveBoard(0);
      setActiveScene(0);
      setDirty(false);
      setStickyTemplate(null);
      setSourceFileHandle(null);
      setWorkingFileHandle(null);
      setFileName(file.name);
    };
    reader.readAsText(file);
    e.target.value = "";
  }, [ensureScenes]);

  // Save to working file (or prompt Save As if no working file yet)
  // Save/download helper - robust fallback for sandboxed environments
  const doDownload = useCallback((pbn) => {
    const blob = new Blob([pbn], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const dlName = fileName ? fileName.replace(/\.pbn$/i, "") + "_curated.pbn" : "lesson.pbn";
    
    // Try multiple approaches
    try {
      // Method 1: window.open (works in some sandboxes)
      const a = document.createElement("a");
      a.href = url;
      a.download = dlName;
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } catch (e) {
      console.log("Download click failed, trying window.open");
      try {
        window.open(url, "_blank");
      } catch (e2) {
        console.log("window.open failed too");
      }
    }
    setTimeout(() => URL.revokeObjectURL(url), 5000);
    setDirty(false);
  }, [fileName]);

  const handleSaveAs = useCallback(async () => {
    if (!boards.length) return;
    const pbn = exportIncludedBoards(boards);
    if (fileSystemWorks) {
      try {
        const suggestedName = fileName
          ? fileName.replace(/\.pbn$/i, "") + "_curated.pbn"
          : "lesson.pbn";
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: "PBN Files", accept: { "text/plain": [".pbn"] } }],
        });
        const writable = await handle.createWritable();
        await writable.write(pbn);
        await writable.close();
        setWorkingFileHandle(handle);
        const file = await handle.getFile();
        setFileName(file.name);
        setDirty(false);
        return;
      } catch (e) {
        if (e.name === "AbortError") return;
      }
    }
    doDownload(pbn);
  }, [boards, fileSystemWorks, fileName, doDownload]);

  const handleSave = useCallback(async () => {
    if (!boards.length) return;
    const pbn = exportIncludedBoards(boards);
    if (fileSystemWorks && workingFileHandle) {
      try {
        const writable = await workingFileHandle.createWritable();
        await writable.write(pbn);
        await writable.close();
        setDirty(false);
        return;
      } catch (e) {
        console.error("Save to handle failed:", e);
      }
    }
    if (fileSystemWorks) {
      try {
        const suggestedName = fileName
          ? fileName.replace(/\.pbn$/i, "") + "_curated.pbn"
          : "lesson.pbn";
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: "PBN Files", accept: { "text/plain": [".pbn"] } }],
        });
        const writable = await handle.createWritable();
        await writable.write(pbn);
        await writable.close();
        setWorkingFileHandle(handle);
        const file = await handle.getFile();
        setFileName(file.name);
        setDirty(false);
        return;
      } catch (e) {
        if (e.name === "AbortError") return;
      }
    }
    doDownload(pbn);
  }, [boards, fileSystemWorks, workingFileHandle, fileName, doDownload]);

  // Keyboard shortcuts are registered after undo/redo are defined (see below)

  const updateBoard = useCallback((updates) => {
    setBoards(prev => prev.map((b, i) => i === activeBoard ? { ...b, ...updates } : b));
    setDirty(true);
  }, [activeBoard]);

  // â”€â”€ Card swap with undo/redo and highlight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [swapHistory, setSwapHistory] = useState([]); // stack of { boardIdx, fromCard, fromSeat, toCard, toSeat, prevHands }
  const [swapFuture, setSwapFuture] = useState([]);
  const [highlightedCards, setHighlightedCards] = useState({}); // { cardId: timestamp }

  // Clear highlights after a delay
  useEffect(() => {
    const keys = Object.keys(highlightedCards);
    if (keys.length === 0) return;
    const timer = setTimeout(() => setHighlightedCards({}), 2500);
    return () => clearTimeout(timer);
  }, [highlightedCards]);

  // Clear highlights when changing boards
  useEffect(() => {
    setHighlightedCards({});
  }, [activeBoard]);

  const handleSwapCards = useCallback((fromCard, fromSeat, toCard, toSeat) => {
    if (fromSeat === toSeat && fromCard === toCard) return;
    setBoards(prev => {
      const newBoards = prev.map((b, i) => {
        if (i !== activeBoard) return b;
        // Save previous hands for undo
        const prevHands = { N: [...b.hands.N], E: [...b.hands.E], S: [...b.hands.S], W: [...b.hands.W] };
        setSwapHistory(h => [...h, { boardIdx: activeBoard, prevHands }]);
        setSwapFuture([]);
        const newHands = { ...b.hands };
        newHands[fromSeat] = b.hands[fromSeat].filter(c => c !== fromCard);
        newHands[toSeat] = b.hands[toSeat].filter(c => c !== toCard);
        newHands[fromSeat] = [...newHands[fromSeat], toCard];
        newHands[toSeat] = [...newHands[toSeat], fromCard];
        return { ...b, hands: newHands };
      });
      return newBoards;
    });
    // Highlight swapped cards
    const now = Date.now();
    setHighlightedCards({ [fromCard + ":" + toSeat]: now, [toCard + ":" + fromSeat]: now });
    setDirty(true);
  }, [activeBoard]);

  const undoSwap = useCallback(() => {
    if (swapHistory.length === 0) return;
    const last = swapHistory[swapHistory.length - 1];
    setSwapHistory(h => h.slice(0, -1));
    setBoards(prev => {
      // Save current hands for redo
      const currentHands = prev[last.boardIdx]?.hands;
      if (currentHands) {
        setSwapFuture(f => [...f, { boardIdx: last.boardIdx, prevHands: { N: [...currentHands.N], E: [...currentHands.E], S: [...currentHands.S], W: [...currentHands.W] } }]);
      }
      return prev.map((b, i) => i === last.boardIdx ? { ...b, hands: last.prevHands } : b);
    });
    setHighlightedCards({});
    setDirty(true);
  }, [swapHistory]);

  const redoSwap = useCallback(() => {
    if (swapFuture.length === 0) return;
    const next = swapFuture[swapFuture.length - 1];
    setSwapFuture(f => f.slice(0, -1));
    setBoards(prev => {
      const currentHands = prev[next.boardIdx]?.hands;
      if (currentHands) {
        setSwapHistory(h => [...h, { boardIdx: next.boardIdx, prevHands: { N: [...currentHands.N], E: [...currentHands.E], S: [...currentHands.S], W: [...currentHands.W] } }]);
      }
      return prev.map((b, i) => i === next.boardIdx ? { ...b, hands: next.prevHands } : b);
    });
    setHighlightedCards({});
    setDirty(true);
  }, [swapFuture]);

  // Keyboard shortcuts: Ctrl/Cmd+S save, Ctrl/Cmd+Z undo, Ctrl/Cmd+Shift+Z / Ctrl+Y redo
  useEffect(() => {
    const handler = (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "s") {
        e.preventDefault();
        handleSave();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === "z" && !e.shiftKey) {
        e.preventDefault();
        undoSwap();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === "z" && e.shiftKey) {
        e.preventDefault();
        redoSwap();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === "y") {
        e.preventDefault();
        redoSwap();
      }
    };
    document.addEventListener("keydown", handler);
    return () => document.removeEventListener("keydown", handler);
  }, [handleSave, undoSwap, redoSwap]);

  const updateScene = useCallback((sceneIdx, updates) => {
    setBoards(prev => prev.map((b, i) => {
      if (i !== activeBoard) return b;
      return { ...b, scenes: b.scenes.map((s, j) => j === sceneIdx ? { ...s, ...updates } : s) };
    }));
    setDirty(true);
  }, [activeBoard]);

  const addScene = useCallback(() => {
    setBoards(prev => prev.map((b, i) => {
      if (i !== activeBoard) return b;
      const prevScene = b.scenes[b.scenes.length - 1];
      const vis = prevScene?.visibility || "NESW";
      return { ...b, scenes: [...b.scenes, { text: `[show ${vis}]\n`, visibility: vis, showcards: [], hint: "" }] };
    }));
    setActiveScene(board?.scenes?.length || 0);
    setDirty(true);
  }, [activeBoard, board]);

  const removeScene = useCallback((idx) => {
    setBoards(prev => prev.map((b, i) => {
      if (i !== activeBoard || b.scenes.length <= 1) return b;
      return { ...b, scenes: b.scenes.filter((_, j) => j !== idx) };
    }));
    if (activeScene >= (board?.scenes?.length || 1) - 1) setActiveScene(Math.max(0, activeScene - 1));
    setDirty(true);
  }, [activeBoard, activeScene, board]);

  // â”€â”€ Apply template (with sticky) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const applyTemplate = useCallback((templateKey) => {
    if (!board) return;
    const updated = applyTemplateToBoard(board, templateKey);
    setBoards(prev => prev.map((b, i) => i === activeBoard ? updated : b));
    setStickyTemplate(templateKey);
    setActiveScene(0);
    setShowTemplatePicker(false);
    setDirty(true);
  }, [board, activeBoard, applyTemplateToBoard]);

  // â”€â”€ Navigate boards (auto-apply sticky template) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const navigateToBoard = useCallback((idx) => {
    setActiveBoard(idx);
    setActiveScene(0);
    setBoards(prev => prev.map((b, i) => {
      if (i !== idx) return b;
      let updated = b;
      // Auto-apply sticky template if board doesn't have one yet
      if (stickyTemplate && !b.templateKey) {
        updated = applyTemplateToBoard(ensureScenes(updated), stickyTemplate);
      }
      // Auto-apply sticky metadata if board doesn't have values
      if (stickyCategory && !updated.category) updated = { ...updated, category: stickyCategory };
      if (stickyDifficulty && !updated.difficulty) updated = { ...updated, difficulty: stickyDifficulty };
      if (stickySkillPath && !updated.skillPath) updated = { ...updated, skillPath: stickySkillPath };
      return updated;
    }));
  }, [stickyTemplate, stickyCategory, stickyDifficulty, stickySkillPath, applyTemplateToBoard, ensureScenes]);

  // â”€â”€ Toggle board include/skip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const toggleIncluded = useCallback(() => {
    updateBoard({ included: !board?.included });
  }, [board, updateBoard]);

  // â”€â”€ Skip & advance to next â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const skipAndNext = useCallback(() => {
    updateBoard({ included: false });
    const nextIdx = boards.findIndex((b, i) => i > activeBoard && b.included);
    if (nextIdx >= 0) navigateToBoard(nextIdx);
    else if (activeBoard < boards.length - 1) navigateToBoard(activeBoard + 1);
  }, [boards, activeBoard, updateBoard, navigateToBoard]);

  // â”€â”€ Generate default commentary (force, ignoring existing) â”€â”€
  const generateDefault = useCallback(() => {
    if (!board) return;
    const templateKey = board.templateKey || stickyTemplate || "bidding";
    if (templateKey === "bidding" && board.auction && board.auction.length > 0) {
      const autoScenes = generateBiddingCommentary(board);
      if (autoScenes) {
        updateBoard({ scenes: autoScenes, templateKey });
        setActiveScene(0);
      }
    }
  }, [board, stickyTemplate, generateBiddingCommentary, updateBoard]);

  // â”€â”€ Tag insertion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const handleTagInsert = useCallback((newFullText, cursorPos) => {
    updateScene(activeScene, { text: newFullText });
    setTimeout(() => {
      if (textareaRef.current && cursorPos !== undefined) {
        textareaRef.current.selectionStart = cursorPos;
        textareaRef.current.selectionEnd = cursorPos;
        textareaRef.current.focus();
      }
    }, 0);
  }, [activeScene, updateScene]);

  const rawPBN = board ? exportBoard(board) : "";

  // â”€â”€ Styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const panelStyle = { background: "#fff", borderRadius: 8, border: "1px solid #e2e8f0", overflow: "hidden" };
  const panelHdr = {
    padding: "8px 12px", borderBottom: "1px solid #e2e8f0", fontSize: 11,
    fontWeight: 700, textTransform: "uppercase", letterSpacing: "0.05em",
    color: "#64748b", fontFamily: "'DM Sans', sans-serif", background: "#f8fafc",
  };
  const labelStyle = { fontSize: 10, fontWeight: 700, color: "#94a3b8", textTransform: "uppercase", letterSpacing: "0.04em", fontFamily: "'DM Sans', sans-serif" };
  const selectStyle = { padding: "4px 6px", borderRadius: 4, border: "1px solid #cbd5e1", fontSize: 12, fontFamily: "'DM Sans', sans-serif", background: "#fff", color: "#1e293b" };
  const inputStyle = { width: "100%", padding: "4px 8px", borderRadius: 4, border: "1px solid #cbd5e1", fontSize: 12, fontFamily: "'DM Sans', sans-serif", color: "#1e293b", boxSizing: "border-box" };

  // â”€â”€ Empty State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (boards.length === 0) {
    return (
      <div style={{ minHeight: "100vh", background: "#f1f5f9", fontFamily: "'DM Sans', -apple-system, sans-serif", display: "flex", flexDirection: "column" }}>
        <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&family=Crimson+Pro:wght@600;700;800&display=swap" rel="stylesheet" />
        <div style={{ flex: 1, display: "flex", alignItems: "center", justifyContent: "center" }}>
          <div style={{ textAlign: "center", maxWidth: 420 }}>
            <div style={{
              width: 72, height: 72, borderRadius: 16, margin: "0 auto 20px",
              background: "linear-gradient(135deg, #3b82f6, #6366f1)",
              display: "flex", alignItems: "center", justifyContent: "center",
              color: "#fff", fontSize: 36, fontWeight: 700,
              boxShadow: "0 8px 32px rgba(99,102,241,0.3)",
            }}>â™ </div>
            <div style={{ fontSize: 32, fontWeight: 800, color: "#0f172a", fontFamily: "'Crimson Pro', serif", marginBottom: 6 }}>Bridge Curator</div>
            <div style={{ fontSize: 15, color: "#64748b", marginBottom: 28, lineHeight: 1.5 }}>
              Author interactive bridge lessons with visual storyboarding.
              <br />Import PBN files, apply lesson templates, and tag bids and plays.
            </div>
            <div style={{ display: "flex", gap: 10, justifyContent: "center" }}>
              <button onClick={handleOpen} style={{
                padding: "12px 24px", borderRadius: 8, border: "none",
                background: "linear-gradient(135deg, #3b82f6, #6366f1)", color: "#fff",
                fontSize: 15, fontWeight: 700, cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
                boxShadow: "0 4px 16px rgba(59,130,246,0.3)",
              }}>Open PBN File</button>
              <button onClick={() => {
                const sample = `[Board "1"]\n[Dealer "W"]\n[Vulnerable "EW"]\n[Deal "N:AT85.KJ3.Q76.K95 KQ64.A985..QJT64 J97.QT76.AT5.A87 32.42.KJ98432.32"]\n[Auction "W"]\n3D Pass Pass 3H Pass 3S Pass 4S Pass Pass Pass\n[Student "N"]\n[Category "Competitive Bidding"]\n[Difficulty "Intermediate"]\n{[show S]\n\nThe bidding has gone as shown. Decide what you would say, then click on BID above. [BID 3\\H]\n\n[NEXT]\n\n[show NS]\n\nYou have a limit raise in \\Ss; if East had not overcalled you would have bid 3\\S.\n\nInstead, you cue-bid 3\\H, promising at least 11 points and support for \\Ss. Partner bids the game.}\n\n[Board "2"]\n[Dealer "N"]\n[Vulnerable "None"]\n[Deal "N:AKQ85.K3.76.KT95 64.A985.QJT4.Q64 J97.QT76.AT5.A87 T32.J42.K9832.32"]\n[Auction "N"]\n1S Pass 2S Pass 4S Pass Pass Pass\n[Student "S"]\n[Category "Declarer Play"]\n\n[Board "3"]\n[Dealer "E"]\n[Vulnerable "NS"]\n[Deal "N:KJ5.AQ3.T76.K952 AT64.985.AQ4.QJ4 Q97.KT76.J85.A87 832.J42.K932.T63"]\n[Auction "E"]\nPass Pass 1C Pass 1NT Pass Pass Pass\n[Student "S"]\n\n[Board "4"]\n[Dealer "S"]\n[Vulnerable "Both"]\n[Deal "N:A85.KJ3.Q764.K95 KQ64.A98..QJT643 JT97.QT76.AT5.A8 32.542.KJ9832.72"]\n[Auction "S"]\n1NT Pass 3NT Pass Pass Pass`;
                const parsed = parsePBNFile(sample).map(b => ensureScenes(b));
                setBoards(parsed); setActiveBoard(0); setActiveScene(0); setDirty(false);
              }} style={{
                padding: "12px 24px", borderRadius: 8, border: "1.5px solid #cbd5e1",
                background: "#fff", color: "#475569", fontSize: 15, fontWeight: 600,
                cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
              }}>Load Sample</button>
            </div>
            <input ref={fileInputRef} type="file" accept=".pbn,.txt" onChange={handleImport} style={{ display: "none" }} />
          </div>
        </div>
      </div>
    );
  }

  return (
    <div style={{ minHeight: "100vh", background: "#f1f5f9", fontFamily: "'DM Sans', -apple-system, sans-serif", display: "flex", flexDirection: "column" }}>
      <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&family=Crimson+Pro:wght@600;700;800&display=swap" rel="stylesheet" />

      {/* Header */}
      <div style={{
        background: "linear-gradient(135deg, #0f172a, #1e293b)",
        padding: "8px 20px", display: "flex", alignItems: "center", justifyContent: "space-between",
      }}>
        <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
          <div style={{
            width: 30, height: 30, borderRadius: 6,
            background: "linear-gradient(135deg, #3b82f6, #6366f1)",
            display: "flex", alignItems: "center", justifyContent: "center",
            color: "#fff", fontSize: 15, fontWeight: 700,
          }}>â™ </div>
          <span style={{ fontSize: 16, fontWeight: 700, color: "#f8fafc", fontFamily: "'Crimson Pro', serif" }}>Bridge Curator</span>
          {stickyTemplate && (
            <span style={{
              fontSize: 10, fontWeight: 600, padding: "2px 6px", borderRadius: 3,
              background: "#1e3a5f", color: "#93c5fd",
            }}>Template: {TEMPLATES[stickyTemplate]?.name}</span>
          )}
          {fileName && (
            <span style={{
              fontSize: 11, fontWeight: 500, color: "#94a3b8",
              maxWidth: 200, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap",
            }} title={fileName}>
              {fileName}
            </span>
          )}
          {dirty && <span style={{ fontSize: 10, color: "#f59e0b", fontWeight: 600 }}>â— Unsaved</span>}
        </div>
        <div style={{ display: "flex", gap: 6 }}>
          <button onClick={handleOpen} style={{
            padding: "5px 12px", borderRadius: 5, border: "1px solid #475569",
            background: "transparent", color: "#94a3b8", fontSize: 12, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Open</button>
          <button onClick={handleSave} style={{
            padding: "5px 12px", borderRadius: 5, border: "1px solid #475569",
            background: workingFileHandle ? "#1e3a5f" : "transparent",
            color: workingFileHandle ? "#93c5fd" : "#94a3b8",
            fontSize: 12, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>Save{!workingFileHandle && "â€¦"}</button>
          {workingFileHandle && (
            <button onClick={handleSaveAs} style={{
              padding: "5px 12px", borderRadius: 5, border: "1px solid #475569",
              background: "transparent", color: "#94a3b8", fontSize: 12, fontWeight: 600,
              cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
            }}>Save Asâ€¦</button>
          )}
          <button onClick={() => setShowPreview(true)} style={{
            padding: "5px 12px", borderRadius: 5, border: "1px solid #475569",
            background: "transparent", color: "#94a3b8", fontSize: 12, fontWeight: 600,
            cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
          }}>â–¶ Preview</button>
          <input ref={fileInputRef} type="file" accept=".pbn,.txt" onChange={handleImport} style={{ display: "none" }} />
        </div>
      </div>

      {/* Board nav */}
      <BoardNav boards={boards} activeIdx={activeBoard} onSelect={navigateToBoard} includedCount={includedCount} />

      {/* Main */}
      {board && (
        <div style={{
          display: "grid", gridTemplateColumns: "minmax(320px, 380px) 1fr 240px",
          gap: 12, padding: 12, flex: 1, minHeight: 0,
          maxWidth: 1400, margin: "0 auto", width: "100%", boxSizing: "border-box",
        }}>
          {/* Left */}
          <div style={{ display: "flex", flexDirection: "column", gap: 10, overflow: "auto" }}>
            {/* Skip/include toggle */}
            <div style={{
              display: "flex", gap: 6, alignItems: "center",
            }}>
              <button onClick={toggleIncluded} style={{
                flex: 1, padding: "6px 12px", borderRadius: 6,
                border: board.included ? "1.5px solid #22c55e" : "1.5px solid #ef4444",
                background: board.included ? "#f0fdf4" : "#fef2f2",
                color: board.included ? "#166534" : "#991b1b",
                fontSize: 12, fontWeight: 700, cursor: "pointer",
                fontFamily: "'DM Sans', sans-serif",
              }}>
                {board.included ? "âœ“ Included" : "âœ— Skipped"}
              </button>
              <button onClick={skipAndNext} style={{
                padding: "6px 12px", borderRadius: 6,
                border: "1.5px solid #e2e8f0", background: "#fff",
                color: "#64748b", fontSize: 12, fontWeight: 600,
                cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
              }}>
                Skip â†’
              </button>
            </div>

            {/* Board diagram */}
            <div style={panelStyle}>
              <div style={{ ...panelHdr, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <span>
                  Board {board.board || activeBoard + 1}
                  {board.templateKey && (
                    <span style={{ marginLeft: 8, fontSize: 10, fontWeight: 600, padding: "1px 5px", borderRadius: 3, background: "#dbeafe", color: "#1e40af" }}>
                      {TEMPLATES[board.templateKey]?.name}
                    </span>
                  )}
                </span>
                <button onClick={() => updateBoard(rotateBoard(board, 2))} title="Rotate deal 180Â°" style={{
                  padding: "2px 8px", borderRadius: 4, border: "1px solid #e2e8f0",
                  background: "#fff", color: "#64748b", fontSize: 11, fontWeight: 600,
                  cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
                }}>Rotate 180Â°</button>
              </div>
              <BoardDiagram hands={board.hands} visibility={currentScene?.visibility || "NESW"} onSwapCards={handleSwapCards} highlightedCards={highlightedCards} />
              {board.metadata && board.metadata.length > 0 && (
                <div style={{
                  padding: "6px 10px", borderTop: "1px solid #e2e8f0",
                  background: "#f8fafc",
                }}>
                  {board.metadata.map((m, i) => (
                    <div key={i} style={{
                      fontSize: 10, color: "#64748b", fontFamily: "'JetBrains Mono', monospace",
                      lineHeight: 1.4,
                    }}>{m}</div>
                  ))}
                </div>
              )}
            </div>

            {/* Auction */}
            <div style={panelStyle}>
              <div style={{ ...panelHdr, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                Auction
                <button onClick={() => setShowAuctionEditor(true)} style={{
                  padding: "2px 8px", borderRadius: 4, border: "1px solid #e2e8f0",
                  background: "#fff", color: "#64748b", fontSize: 11, fontWeight: 600,
                  cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
                }}>Edit</button>
              </div>
              <div style={{ padding: 8 }}>
                <AuctionDisplay auction={board.auction} dealer={board.dealer}
                  onBidClick={(idx) => setAlertBidIdx(idx)} />
              </div>
            </div>

            {/* Settings */}
            <div style={panelStyle}>
              <div style={panelHdr}>Settings</div>
              <div style={{ padding: 10, display: "flex", flexDirection: "column", gap: 8 }}>
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 6 }}>
                  <div>
                    <label style={labelStyle}>Dealer</label>
                    <select value={board.dealer} onChange={e => updateBoard({ dealer: e.target.value })}
                      style={{ ...selectStyle, width: "100%", marginTop: 2 }}>
                      {SEATS.map(s => <option key={s} value={s}>{SEAT_NAMES[s]}</option>)}
                    </select>
                  </div>
                  <div>
                    <label style={labelStyle}>Student</label>
                    <select value={board.student} onChange={e => updateBoard({ student: e.target.value })}
                      style={{ ...selectStyle, width: "100%", marginTop: 2 }}>
                      <option value="">Not set</option>
                      {SEATS.map(s => <option key={s} value={s}>{SEAT_NAMES[s]}</option>)}
                    </select>
                  </div>
                </div>
                <div>
                  <label style={labelStyle}>Vulnerability</label>
                  <select value={board.vulnerable} onChange={e => updateBoard({ vulnerable: e.target.value })}
                    style={{ ...selectStyle, width: "100%", marginTop: 2 }}>
                    {VULNERABILITIES.map(v => <option key={v} value={v}>{v}</option>)}
                  </select>
                </div>
                <div>
                  <label style={labelStyle}>Category</label>
                  <div style={{ marginTop: 2 }}>
                    <FilteredCombo
                      value={board.category}
                      onChange={(v) => { updateBoard({ category: v }); setStickyCategory(v); }}
                      options={CATEGORIES}
                      placeholder="e.g. Competitive Bidding"
                    />
                  </div>
                </div>
                <div>
                  <label style={labelStyle}>Difficulty</label>
                  <div style={{ marginTop: 2 }}>
                    <FilteredCombo
                      value={board.difficulty}
                      onChange={(v) => { updateBoard({ difficulty: v }); setStickyDifficulty(v); }}
                      options={DIFFICULTIES}
                      placeholder="e.g. intermediate"
                    />
                  </div>
                </div>
                <div>
                  <label style={labelStyle}>Skill Path</label>
                  <div style={{ marginTop: 2 }}>
                    <FilteredCombo
                      value={board.skillPath}
                      onChange={(v) => { updateBoard({ skillPath: v }); setStickySkillPath(v); }}
                      options={SKILL_PATHS}
                      placeholder="e.g. bidding_conventions/two_over_one"
                    />
                  </div>
                </div>
                <button onClick={() => setShowTemplatePicker(true)} style={{
                  padding: "7px 12px", borderRadius: 5, border: "1.5px solid #e2e8f0",
                  background: "#fff", color: "#475569", fontSize: 12, fontWeight: 600,
                  cursor: "pointer", fontFamily: "'DM Sans', sans-serif", marginTop: 4, width: "100%",
                }}>Apply Templateâ€¦</button>
                {board.auction && board.auction.length > 0 && (
                  <button onClick={generateDefault} style={{
                    padding: "7px 12px", borderRadius: 5, border: "1.5px solid #f59e0b",
                    background: "#fffbeb", color: "#92400e", fontSize: 12, fontWeight: 600,
                    cursor: "pointer", fontFamily: "'DM Sans', sans-serif", width: "100%",
                  }}>âš¡ Generate Bidding Scaffold</button>
                )}
              </div>
            </div>
          </div>

          {/* Center: Scene Editor */}
          <div style={{ display: "flex", flexDirection: "column", gap: 10, minHeight: 0 }}>
            {currentScene && (
              <div style={{ ...panelStyle, flex: 1, display: "flex", flexDirection: "column" }}>
                <div style={{ ...panelHdr, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                  <span>Scene {activeScene + 1} of {board.scenes.length}</span>
                  <VisibilityToggle
                    visibility={currentScene.visibility}
                    onChange={(vis) => {
                      // Update visibility and sync the [show X] tag in the text
                      const text = currentScene.text;
                      const showTag = `[show ${vis}]`;
                      let newText;
                      if (/^\[show\s+[NESW]+\]/i.test(text.trim())) {
                        newText = text.replace(/^\s*\[show\s+[NESW]+\]/i, showTag);
                      } else {
                        newText = showTag + "\n" + text;
                      }
                      updateScene(activeScene, { visibility: vis, text: newText });
                    }}
                  />
                </div>
                {currentScene.hint && !currentScene.text.trim() && (
                  <div style={{
                    padding: "6px 12px", background: "#fefce8", borderBottom: "1px solid #fef08a",
                    fontSize: 12, color: "#854d0e", fontStyle: "italic",
                  }}>ðŸ’¡ {currentScene.hint}</div>
                )}
                <div style={{ padding: "8px 12px", borderBottom: "1px solid #f1f5f9" }}>
                  <TagToolbar textareaRef={textareaRef}
                    onInsert={(newText, cursor) => {
                      if (typeof newText === "string" && cursor !== undefined) handleTagInsert(newText, cursor);
                    }}
                  />
                </div>
                <div style={{ flex: 1, padding: 12 }}>
                  <HighlightedTextarea
                    textareaRef={textareaRef}
                    value={currentScene.text}
                    onChange={(e) => {
                      const newText = e.target.value;
                      const updates = { text: newText };
                      // Sync visibility from [show X] tag in text
                      const showMatch = newText.match(/\[show\s+([NESW]+)\]/i);
                      if (showMatch) updates.visibility = showMatch[1].toUpperCase();
                      updateScene(activeScene, updates);
                    }}
                    placeholder="Write your instructional narrative here. Use the tag toolbar above to insert control tags inline, or type them directly."
                    style={{
                      width: "100%", height: "100%", minHeight: 200, padding: 12,
                      borderRadius: 6, border: "1px solid #e2e8f0",
                      fontSize: 14, fontFamily: "'DM Sans', sans-serif",
                      color: "#1e293b", lineHeight: 1.7, resize: "vertical",
                      boxSizing: "border-box", background: "#fafbfc",
                    }}
                  />
                </div>
              </div>
            )}
            <div style={panelStyle}>
              <div style={{ ...panelHdr, cursor: "pointer", userSelect: "none", display: "flex", alignItems: "center", gap: 6 }}
                onClick={() => setShowRaw(!showRaw)}>
                <span style={{ fontSize: 12 }}>{showRaw ? "â–¾" : "â–¸"}</span> PBN Output
              </div>
              {showRaw && (
                <pre style={{
                  padding: 12, fontSize: 11, fontFamily: "'JetBrains Mono', monospace",
                  color: "#334155", background: "#f8fafc", margin: 0,
                  whiteSpace: "pre-wrap", wordBreak: "break-word",
                  maxHeight: 240, overflow: "auto", lineHeight: 1.5,
                }}>{rawPBN}</pre>
              )}
            </div>
          </div>

          {/* Right: Storyboard */}
          <div style={{ display: "flex", flexDirection: "column", gap: 0 }}>
            <div style={{ ...panelStyle, flex: 1, display: "flex", flexDirection: "column" }}>
              <div style={{ ...panelHdr, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <span>Storyboard</span>
                <button onClick={addScene} style={{
                  padding: "2px 8px", borderRadius: 4, border: "none",
                  background: "#3b82f6", color: "#fff", fontSize: 10, fontWeight: 700,
                  cursor: "pointer", fontFamily: "'DM Sans', sans-serif",
                }}>+ Scene</button>
              </div>
              <div style={{ padding: 8, display: "flex", flexDirection: "column", gap: 6, overflow: "auto", flex: 1 }}>
                {board.scenes?.map((scene, i) => (
                  <SceneMiniCard key={i} scene={scene} index={i}
                    isActive={i === activeScene}
                    onClick={() => setActiveScene(i)}
                    onRemove={() => removeScene(i)}
                    canRemove={board.scenes.length > 1}
                  />
                ))}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Modals */}
      {showTemplatePicker && (
        <TemplatePicker onSelect={applyTemplate} onClose={() => setShowTemplatePicker(false)} stickyTemplate={stickyTemplate} />
      )}
      {showPreview && board && (
        <PreviewMode board={board} onClose={() => setShowPreview(false)} />
      )}
      {showAuctionEditor && board && (
        <AuctionEditor
          auction={board.auction}
          dealer={board.dealer}
          onSave={(newAuction) => {
            updateBoard({ auction: newAuction });
            setDirty(true);
          }}
          onClose={() => setShowAuctionEditor(false)}
        />
      )}
      {alertBidIdx !== null && board && board.auction[alertBidIdx] && (
        <AlertDialog
          bid={board.auction[alertBidIdx].bid}
          alert={board.auction[alertBidIdx].alert}
          onSave={(text) => {
            const newAuction = board.auction.map((e, i) =>
              i === alertBidIdx ? { ...e, alert: text } : e
            );
            updateBoard({ auction: newAuction });
            setDirty(true);
            setAlertBidIdx(null);
          }}
          onClear={() => {
            const newAuction = board.auction.map((e, i) => {
              if (i !== alertBidIdx) return e;
              const { alert, ...rest } = e;
              return rest;
            });
            updateBoard({ auction: newAuction });
            setDirty(true);
            setAlertBidIdx(null);
          }}
          onClose={() => setAlertBidIdx(null)}
        />
      )}
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(BridgeCurator));
  </script>
</body>
</html>
