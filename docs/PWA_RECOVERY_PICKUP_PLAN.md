# PWA Recovery Pickup — Implementation Plan

## Problem

When Bridge Classroom runs as a PWA (Add to Home Screen) on iPad/iOS, the email magic link recovery flow fails because:

1. The recovery email opens in the Gmail app (or other mail client), not Safari
2. The magic link opens in Chrome or Safari — **not** the PWA
3. PWAs on iOS have **isolated localStorage** — completely separate from Safari and Chrome
4. Even if the magic link successfully claims the recovery token in a browser, the PWA never sees the restored key

## Solution: Server-Mediated Pickup

Add a polling-based "pickup" mechanism so the PWA can retrieve the recovered key from the server after the magic link is claimed in any browser or app.

### Flow Diagram

```
PWA                          Server                      Browser (any)
 │                              │                              │
 │  POST /api/recovery/request  │                              │
 │  { email, pickup_id }        │                              │
 │─────────────────────────────>│                              │
 │                              │  Generate recovery token     │
 │                              │  Store pickup_id with token  │
 │  { success, user_id }        │  Send email with magic link  │
 │<─────────────────────────────│  (includes &pickup=<id>)     │
 │                              │                              │
 │  Start polling               │                              │
 │  GET /api/recovery/pickup    │                              │
 │  ?pickup_id=<id>             │                              │
 │─────────────────────────────>│  → { ready: false }          │
 │<─────────────────────────────│                              │
 │                              │                              │
 │         ... user checks email, taps link ...                │
 │                              │                              │
 │                              │  POST /api/recovery/claim    │
 │                              │  { user_id, token }          │
 │                              │<─────────────────────────────│
 │                              │  Decrypt secret key          │
 │                              │  Store in recovery_pickups   │
 │                              │  → { success, message }      │
 │                              │─────────────────────────────>│
 │                              │                              │
 │                              │  Page shows:                 │
 │                              │  "✓ Your app should be       │
 │                              │   signed in now. You can     │
 │                              │   close this page."          │
 │                              │                              │
 │  GET /api/recovery/pickup    │                              │
 │  ?pickup_id=<id>             │                              │
 │─────────────────────────────>│                              │
 │                              │  → { ready: true,            │
 │  Restore key to localStorage │     user: { id, name,        │
 │  Show dashboard              │     email, secret_key, ... } │
 │<─────────────────────────────│  }                           │
 │                              │  Delete pickup record        │
```

## PWA Detection

```javascript
function isPWA() {
  return window.matchMedia('(display-mode: standalone)').matches
    || window.navigator.standalone === true;  // iOS Safari specifically
}
```

Use this to branch at the recovery trigger point. The existing browser-based magic link flow remains completely unchanged for non-PWA contexts.

## Database Changes

### New Table: `recovery_pickups`

```sql
CREATE TABLE IF NOT EXISTS recovery_pickups (
  id TEXT PRIMARY KEY,                -- UUID
  pickup_id TEXT NOT NULL UNIQUE,     -- Random ID generated by the PWA
  user_id TEXT NOT NULL,
  encrypted_user_data TEXT,           -- JSON blob: { id, first_name, last_name, email, secret_key, classroom }
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,           -- 10 minutes from creation
  claimed INTEGER NOT NULL DEFAULT 0, -- Set to 1 when PWA picks it up
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_recovery_pickups_pickup_id ON recovery_pickups(pickup_id);
```

**Lifecycle:**
- Created when `/api/recovery/request` is called with a `pickup_id`
- Initially has `encrypted_user_data = NULL` (waiting for claim)
- Populated when `/api/recovery/claim` is called for the associated token
- Deleted when the PWA picks it up, or after 10-minute TTL

### Modified Table: `recovery_tokens`

Add a column to associate a token with a pickup:

```sql
ALTER TABLE recovery_tokens ADD COLUMN pickup_id TEXT;
```

## API Changes

### Modified: `POST /api/recovery/request`

**New optional field:** `pickup_id`

```json
{
  "email": "margaret@example.com",
  "pickup_id": "random-uuid-from-pwa"    // NEW — only sent by PWA
}
```

**Server behavior:**
1. Existing logic unchanged (find user, generate token, etc.)
2. If `pickup_id` is present:
   - Create a `recovery_pickups` row with `pickup_id`, `user_id`, `encrypted_user_data = NULL`, 10-min expiry
   - Store `pickup_id` on the `recovery_tokens` row
   - Append `&pickup=true` to the magic link URL (so the claim page knows to show the "close this page" message)
3. Send email as usual

### Modified: `POST /api/recovery/claim`

**No changes to the request format.** The branching is server-side based on whether the token has an associated `pickup_id`.

**Server behavior:**
1. Existing logic: validate token, decrypt secret key (unchanged)
2. Look up the token's `pickup_id`
3. **If `pickup_id` exists** (PWA flow):
   - Write the decrypted user data to `recovery_pickups.encrypted_user_data` as JSON
   - Return `{ success: true, message: "Recovery complete. Return to your app.", pickup: true }`
   - Do NOT return the secret key in this response
4. **If no `pickup_id`** (browser flow):
   - Return existing response with user data and secret key (unchanged)

### New: `GET /api/recovery/pickup`

**Request:**
```
GET /api/recovery/pickup?pickup_id=<uuid>
```

**Response (not ready yet):**
```json
{
  "ready": false
}
```

**Response (ready):**
```json
{
  "ready": true,
  "user": {
    "id": "uuid",
    "first_name": "Margaret",
    "last_name": "Thompson",
    "email": "margaret@example.com",
    "secret_key": "base64-encoded-aes-key",
    "classroom": "tuesday-am"
  }
}
```

**Server behavior:**
1. Look up `recovery_pickups` by `pickup_id`
2. If not found or expired → `{ ready: false }`
3. If found but `encrypted_user_data` is NULL → `{ ready: false }` (claim hasn't happened yet)
4. If found and `encrypted_user_data` is populated:
   - Return the user data
   - Delete the pickup row (one-time retrieval)

## Frontend Changes

### Recovery Flow (in PWA mode)

```javascript
async function startPWARecovery(email) {
  const pickupId = crypto.randomUUID();

  // 1. Request recovery with pickup_id
  const response = await fetch('/api/recovery/request', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, pickup_id: pickupId })
  });

  if (!response.ok) throw new Error('Recovery request failed');

  // 2. Show "check your email" UI
  showRecoveryWaitingUI();

  // 3. Poll for pickup
  const user = await pollForPickup(pickupId);

  // 4. Restore to localStorage
  restoreUserFromRecovery(user);
}

async function pollForPickup(pickupId, maxAttempts = 200, intervalMs = 3000) {
  for (let i = 0; i < maxAttempts; i++) {  // ~10 minutes
    const response = await fetch(`/api/recovery/pickup?pickup_id=${pickupId}`);
    const data = await response.json();

    if (data.ready) {
      return data.user;
    }

    await new Promise(resolve => setTimeout(resolve, intervalMs));
  }

  throw new Error('Recovery timed out — please try again');
}
```

### Recovery Trigger (branching point)

In the existing registration/recovery detection code, add the PWA branch:

```javascript
if (existingUser) {
  if (isPWA()) {
    await startPWARecovery(email);
  } else {
    // Existing flow: show "check your email" and wait for
    // magic link to open in this same browser context
    await startBrowserRecovery(email);
  }
}
```

### Magic Link Claim Page (PWA variant)

When the magic link URL includes `&pickup=true`, the claim page should:

1. Call `POST /api/recovery/claim` with the token (as usual)
2. Instead of trying to restore localStorage, show a simple confirmation:

```html
<div style="text-align: center; padding: 40px; font-family: system-ui;">
  <div style="font-size: 48px;">✓</div>
  <h2>Recovery Complete</h2>
  <p>Your Bridge Classroom app should be signed in now.</p>
  <p>You can close this page.</p>
</div>
```

This page works in any browser or webview — it doesn't need access to the PWA's storage.

## Security Considerations

### Pickup ID as Authorization

The `pickup_id` is a random UUID generated by the PWA and never exposed in the email or magic link URL. Only the PWA that initiated the recovery knows the `pickup_id`, so only it can poll for the result. This prevents:

- Other apps/tabs from intercepting the recovery
- Someone with just a `user_id` from polling for keys

### Short TTL

Pickup records expire after 10 minutes. Even if a `pickup_id` were somehow leaked, the window of exposure is very small.

### One-Time Retrieval

The pickup record is deleted after the PWA retrieves it. No replay possible.

### No New Trust Assumptions

The security is still gated by the email magic link token (single-use, 1-hour expiry, SHA-256 hashed on server). The pickup mechanism just changes *where* the decrypted key is delivered, not *how* it's authorized.

### Sensitive Data at Rest

The `encrypted_user_data` field contains the plaintext secret key for a short window (between claim and pickup, typically seconds). This is comparable to the existing flow where the key is returned in an HTTPS response body. For additional hardening, you could encrypt this field with the `RECOVERY_SECRET`, but given the short TTL and one-time retrieval, it's likely not necessary for a classroom app.

## Implementation Order

1. **Database migration** — Add `recovery_pickups` table and `pickup_id` column to `recovery_tokens`
2. **Server: `GET /api/recovery/pickup`** — New endpoint (simplest to implement first, can test independently)
3. **Server: Modify `POST /api/recovery/request`** — Accept `pickup_id`, create pickup row, include in token
4. **Server: Modify `POST /api/recovery/claim`** — Branch on `pickup_id` presence, write to pickup row
5. **Frontend: PWA detection** — Add `isPWA()` utility
6. **Frontend: Recovery branching** — Add PWA recovery path with polling
7. **Frontend: Claim page variant** — Show "close this page" message when `&pickup=true`
8. **Cleanup: TTL enforcement** — Add a scheduled task or check-on-access to delete expired pickup rows

## Testing Checklist

- [ ] Browser recovery flow still works unchanged (no `pickup_id` sent)
- [ ] PWA on iPad: registration detects existing user, starts PWA recovery
- [ ] PWA shows "check your email" waiting state with polling indicator
- [ ] Magic link in Gmail app opens claim page in browser
- [ ] Claim page shows "✓ close this page" (not the full app)
- [ ] PWA automatically detects recovery and restores account
- [ ] Expired pickups return `{ ready: false }`
- [ ] Pickup record deleted after retrieval (can't be replayed)
- [ ] Multiple concurrent recoveries don't interfere (different pickup_ids)
- [ ] Timeout after 10 minutes shows appropriate error in PWA

## Notes

- The `pickup_id` is **not** included in the email or magic link URL. This is intentional — it's a secret known only to the PWA session that initiated recovery.
- The `&pickup=true` flag in the magic link URL is a simple boolean hint for the claim page UI. It carries no security significance.
- Consider adding a visual polling indicator in the PWA (e.g., "Waiting for you to click the link in your email...") so students know the app is actively waiting.
- If the student closes the PWA while polling, they'll need to restart the recovery process. The old pickup will expire harmlessly.
